{
  "meta": {
    "projectName": "Your Project Name",
    "version": "1.0.0",
    "source": "scripts/prd.txt",
    "description": "Tasks generated from PRD",
    "totalTasksGenerated": 20,
    "tasksIncluded": 20
  },
  "tasks": [
    {
      "id": 1,
      "title": "Implement Task Data Structure",
      "description": "Design and implement the core tasks.json structure that will serve as the single source of truth for the system.",
      "status": "done",
      "dependencies": [],
      "priority": "high",
      "details": "Create the foundational data structure including:\n- JSON schema for tasks.json\n- Task model with all required fields (id, title, description, status, dependencies, priority, details, testStrategy, subtasks)\n- Validation functions for the task model\n- Basic file system operations for reading/writing tasks.json\n- Error handling for file operations",
      "testStrategy": "Verify that the tasks.json structure can be created, read, and validated. Test with sample data to ensure all fields are properly handled and that validation correctly identifies invalid structures.",
      "subtasks": [],
      "previousStatus": "in-progress"
    },
    {
      "id": 2,
      "title": "Develop Command Line Interface Foundation",
      "description": "Create the basic CLI structure using Commander.js with command parsing and help documentation.",
      "status": "done",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "Implement the CLI foundation including:\n- Set up Commander.js for command parsing\n- Create help documentation for all commands\n- Implement colorized console output for better readability\n- Add logging system with configurable levels\n- Handle global options (--help, --version, --file, --quiet, --debug, --json)",
      "testStrategy": "Test each command with various parameters to ensure proper parsing. Verify help documentation is comprehensive and accurate. Test logging at different verbosity levels.",
      "subtasks": []
    },
    {
      "id": 3,
      "title": "Implement Basic Task Operations",
      "description": "Create core functionality for managing tasks including listing, creating, updating, and deleting tasks.",
      "status": "done",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "Implement the following task operations:\n- List tasks with filtering options\n- Create new tasks with required fields\n- Update existing task properties\n- Delete tasks\n- Change task status (pending/done/deferred)\n- Handle dependencies between tasks\n- Manage task priorities",
      "testStrategy": "Test each operation with valid and invalid inputs. Verify that dependencies are properly tracked and that status changes are reflected correctly in the tasks.json file.",
      "subtasks": []
    },
    {
      "id": 4,
      "title": "Create Task File Generation System",
      "description": "Implement the system for generating individual task files from the tasks.json data structure.",
      "status": "done",
      "dependencies": [
        1,
        3
      ],
      "priority": "medium",
      "details": "Build the task file generation system including:\n- Create task file templates\n- Implement generation of task files from tasks.json\n- Add bi-directional synchronization between task files and tasks.json\n- Implement proper file naming and organization\n- Handle updates to task files reflecting back to tasks.json",
      "testStrategy": "Generate task files from sample tasks.json data and verify the content matches the expected format. Test synchronization by modifying task files and ensuring changes are reflected in tasks.json.",
      "subtasks": [
        {
          "id": 1,
          "title": "Design Task File Template Structure",
          "description": "Create the template structure for individual task files that will be generated from tasks.json. This includes defining the format with sections for task ID, title, status, dependencies, priority, description, details, test strategy, and subtasks. Implement a template engine or string formatting system that can populate these templates with task data. The template should follow the format specified in the PRD's Task File Format section.",
          "status": "done",
          "dependencies": [],
          "acceptanceCriteria": "- Template structure matches the specification in the PRD\n- Template includes all required sections (ID, title, status, dependencies, etc.)\n- Template supports proper formatting of multi-line content like details and test strategy\n- Template handles subtasks correctly, including proper indentation and formatting\n- Template system is modular and can be easily modified if requirements change"
        },
        {
          "id": 2,
          "title": "Implement Task File Generation Logic",
          "description": "Develop the core functionality to generate individual task files from the tasks.json data structure. This includes reading the tasks.json file, iterating through each task, applying the template to each task's data, and writing the resulting content to appropriately named files in the tasks directory. Ensure proper error handling for file operations and data validation.",
          "status": "done",
          "dependencies": [
            1
          ],
          "acceptanceCriteria": "- Successfully reads tasks from tasks.json\n- Correctly applies template to each task's data\n- Generates files with proper naming convention (e.g., task_001.txt)\n- Creates the tasks directory if it doesn't exist\n- Handles errors gracefully (file not found, permission issues, etc.)\n- Validates task data before generation to prevent errors\n- Logs generation process with appropriate verbosity levels"
        },
        {
          "id": 3,
          "title": "Implement File Naming and Organization System",
          "description": "Create a consistent system for naming and organizing task files. Implement a function that generates standardized filenames based on task IDs (e.g., task_001.txt for task ID 1). Design the directory structure for storing task files according to the PRD specification. Ensure the system handles task ID formatting consistently and prevents filename collisions.",
          "status": "done",
          "dependencies": [
            1
          ],
          "acceptanceCriteria": "- Generates consistent filenames based on task IDs with proper zero-padding\n- Creates and maintains the correct directory structure as specified in the PRD\n- Handles special characters or edge cases in task IDs appropriately\n- Prevents filename collisions between different tasks\n- Provides utility functions for converting between task IDs and filenames\n- Maintains backward compatibility if the naming scheme needs to evolve"
        },
        {
          "id": 4,
          "title": "Implement Task File to JSON Synchronization",
          "description": "Develop functionality to read modified task files and update the corresponding entries in tasks.json. This includes parsing the task file format, extracting structured data, validating the changes, and updating the tasks.json file accordingly. Ensure the system can handle concurrent modifications and resolve conflicts appropriately.",
          "status": "done",
          "dependencies": [
            1,
            3,
            2
          ],
          "acceptanceCriteria": "- Successfully parses task files to extract structured data\n- Validates parsed data against the task model schema\n- Updates tasks.json with changes from task files\n- Handles conflicts when the same task is modified in both places\n- Preserves task relationships and dependencies during synchronization\n- Provides clear error messages for parsing or validation failures\n- Updates the \"updatedAt\" timestamp in tasks.json metadata"
        },
        {
          "id": 5,
          "title": "Implement Change Detection and Update Handling",
          "description": "Create a system to detect changes in task files and tasks.json, and handle updates bidirectionally. This includes implementing file watching or comparison mechanisms, determining which version is newer, and applying changes in the appropriate direction. Ensure the system handles edge cases like deleted files, new tasks, and conflicting changes.",
          "status": "done",
          "dependencies": [
            1,
            3,
            4,
            2
          ],
          "acceptanceCriteria": "- Detects changes in both task files and tasks.json\n- Determines which version is newer based on modification timestamps or content\n- Applies changes in the appropriate direction (file to JSON or JSON to file)\n- Handles edge cases like deleted files, new tasks, and renamed tasks\n- Provides options for manual conflict resolution when necessary\n- Maintains data integrity during the synchronization process\n- Includes a command to force synchronization in either direction\n- Logs all synchronization activities for troubleshooting\n\nEach of these subtasks addresses a specific component of the task file generation system, following a logical progression from template design to bidirectional synchronization. The dependencies ensure that prerequisites are completed before dependent work begins, and the acceptance criteria provide clear guidelines for verifying each subtask's completion."
        }
      ]
    },
    {
      "id": 5,
      "title": "Integrate Anthropic Claude API",
      "description": "Set up the integration with Claude API for AI-powered task generation and expansion.",
      "status": "done",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "Implement Claude API integration including:\n- API authentication using environment variables\n- Create prompt templates for various operations\n- Implement response handling and parsing\n- Add error management with retries and exponential backoff\n- Implement token usage tracking\n- Create configurable model parameters",
      "testStrategy": "Test API connectivity with sample prompts. Verify authentication works correctly with different API keys. Test error handling by simulating API failures.",
      "subtasks": [
        {
          "id": 1,
          "title": "Configure API Authentication System",
          "description": "Create a dedicated module for Anthropic API authentication. Implement a secure system to load API keys from environment variables using dotenv. Include validation to ensure API keys are properly formatted and present. Create a configuration object that will store all Claude-related settings including API keys, base URLs, and default parameters.",
          "status": "done",
          "dependencies": [],
          "acceptanceCriteria": "- Environment variables are properly loaded from .env file\n- API key validation is implemented with appropriate error messages\n- Configuration object includes all necessary Claude API parameters\n- Authentication can be tested with a simple API call\n- Documentation is added for required environment variables"
        },
        {
          "id": 2,
          "title": "Develop Prompt Template System",
          "description": "Create a flexible prompt template system for Claude API interactions. Implement a PromptTemplate class that can handle variable substitution, system and user messages, and proper formatting according to Claude's requirements. Include templates for different operations (task generation, task expansion, etc.) with appropriate instructions and constraints for each use case.",
          "status": "done",
          "dependencies": [
            1
          ],
          "acceptanceCriteria": "- PromptTemplate class supports variable substitution\n- System and user message separation is properly implemented\n- Templates exist for all required operations (task generation, expansion, etc.)\n- Templates include appropriate constraints and formatting instructions\n- Template system is unit tested with various inputs"
        },
        {
          "id": 3,
          "title": "Implement Response Handling and Parsing",
          "description": "Create a response handling system that processes Claude API responses. Implement JSON parsing for structured outputs, error detection in responses, and extraction of relevant information. Build utility functions to transform Claude's responses into the application's data structures. Include validation to ensure responses meet expected formats.",
          "status": "done",
          "dependencies": [
            1,
            2
          ],
          "acceptanceCriteria": "- Response parsing functions handle both JSON and text formats\n- Error detection identifies malformed or unexpected responses\n- Utility functions transform responses into task data structures\n- Validation ensures responses meet expected schemas\n- Edge cases like empty or partial responses are handled gracefully"
        },
        {
          "id": 4,
          "title": "Build Error Management with Retry Logic",
          "description": "Implement a robust error handling system for Claude API interactions. Create middleware that catches API errors, network issues, and timeout problems. Implement exponential backoff retry logic that increases wait time between retries. Add configurable retry limits and timeout settings. Include detailed logging for troubleshooting API issues.",
          "status": "done",
          "dependencies": [
            1,
            3
          ],
          "acceptanceCriteria": "- All API errors are caught and handled appropriately\n- Exponential backoff retry logic is implemented\n- Retry limits and timeouts are configurable\n- Detailed error logging provides actionable information\n- System degrades gracefully when API is unavailable\n- Unit tests verify retry behavior with mocked API failures"
        },
        {
          "id": 5,
          "title": "Implement Token Usage Tracking",
          "description": "Create a token tracking system to monitor Claude API usage. Implement functions to count tokens in prompts and responses. Build a logging system that records token usage per operation. Add reporting capabilities to show token usage trends and costs. Implement configurable limits to prevent unexpected API costs.",
          "status": "done",
          "dependencies": [
            1,
            3
          ],
          "acceptanceCriteria": "- Token counting functions accurately estimate usage\n- Usage logging records tokens per operation type\n- Reporting functions show usage statistics and estimated costs\n- Configurable limits can prevent excessive API usage\n- Warning system alerts when approaching usage thresholds\n- Token tracking data is persisted between application runs"
        },
        {
          "id": 6,
          "title": "Create Model Parameter Configuration System",
          "description": "Implement a flexible system for configuring Claude model parameters. Create a configuration module that manages model selection, temperature, top_p, max_tokens, and other parameters. Build functions to customize parameters based on operation type. Add validation to ensure parameters are within acceptable ranges. Include preset configurations for different use cases (creative, precise, etc.).",
          "status": "done",
          "dependencies": [
            1,
            5
          ],
          "acceptanceCriteria": "- Configuration module manages all Claude model parameters\n- Parameter customization functions exist for different operations\n- Validation ensures parameters are within acceptable ranges\n- Preset configurations exist for different use cases\n- Parameters can be overridden at runtime when needed\n- Documentation explains parameter effects and recommended values\n- Unit tests verify parameter validation and configuration loading"
        }
      ]
    },
    {
      "id": 6,
      "title": "Build PRD Parsing System",
      "description": "Create the system for parsing Product Requirements Documents into structured task lists.",
      "status": "done",
      "dependencies": [
        1,
        5
      ],
      "priority": "high",
      "details": "Implement PRD parsing functionality including:\n- PRD file reading from specified path\n- Prompt engineering for effective PRD parsing\n- Convert PRD content to task structure via Claude API\n- Implement intelligent dependency inference\n- Add priority assignment logic\n- Handle large PRDs by chunking if necessary",
      "testStrategy": "Test with sample PRDs of varying complexity. Verify that generated tasks accurately reflect the requirements in the PRD. Check that dependencies and priorities are logically assigned.",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement PRD File Reading Module",
          "description": "Create a module that can read PRD files from a specified file path. The module should handle different file formats (txt, md, docx) and extract the text content. Implement error handling for file not found, permission issues, and invalid file formats. Add support for encoding detection and proper text extraction to ensure the content is correctly processed regardless of the source format.",
          "status": "done",
          "dependencies": [],
          "acceptanceCriteria": "- Function accepts a file path and returns the PRD content as a string\n- Supports at least .txt and .md file formats (with extensibility for others)\n- Implements robust error handling with meaningful error messages\n- Successfully reads files of various sizes (up to 10MB)\n- Preserves formatting where relevant for parsing (headings, lists, code blocks)"
        },
        {
          "id": 2,
          "title": "Design and Engineer Effective PRD Parsing Prompts",
          "description": "Create a set of carefully engineered prompts for Claude API that effectively extract structured task information from PRD content. Design prompts that guide Claude to identify tasks, dependencies, priorities, and implementation details from unstructured PRD text. Include system prompts, few-shot examples, and output format specifications to ensure consistent results.",
          "status": "done",
          "dependencies": [],
          "acceptanceCriteria": "- At least 3 different prompt templates optimized for different PRD styles/formats\n- Prompts include clear instructions for identifying tasks, dependencies, and priorities\n- Output format specification ensures Claude returns structured, parseable data\n- Includes few-shot examples to guide Claude's understanding\n- Prompts are optimized for token efficiency while maintaining effectiveness"
        },
        {
          "id": 3,
          "title": "Implement PRD to Task Conversion System",
          "description": "Develop the core functionality that sends PRD content to Claude API and converts the response into the task data structure. This includes sending the engineered prompts with PRD content to Claude, parsing the structured response, and transforming it into valid task objects that conform to the task model. Implement validation to ensure the generated tasks meet all requirements.",
          "status": "done",
          "dependencies": [
            1
          ],
          "acceptanceCriteria": "- Successfully sends PRD content to Claude API with appropriate prompts\n- Parses Claude's response into structured task objects\n- Validates generated tasks against the task model schema\n- Handles API errors and response parsing failures gracefully\n- Generates unique and sequential task IDs"
        },
        {
          "id": 4,
          "title": "Build Intelligent Dependency Inference System",
          "description": "Create an algorithm that analyzes the generated tasks and infers logical dependencies between them. The system should identify which tasks must be completed before others based on the content and context of each task. Implement both explicit dependency detection (from Claude's output) and implicit dependency inference (based on task relationships and logical ordering).",
          "status": "done",
          "dependencies": [
            1,
            3
          ],
          "acceptanceCriteria": "- Correctly identifies explicit dependencies mentioned in task descriptions\n- Infers implicit dependencies based on task context and relationships\n- Prevents circular dependencies in the task graph\n- Provides confidence scores for inferred dependencies\n- Allows for manual override/adjustment of detected dependencies"
        },
        {
          "id": 5,
          "title": "Implement Priority Assignment Logic",
          "description": "Develop a system that assigns appropriate priorities (high, medium, low) to tasks based on their content, dependencies, and position in the PRD. Create algorithms that analyze task descriptions, identify critical path tasks, and consider factors like technical risk and business value. Implement both automated priority assignment and manual override capabilities.",
          "status": "done",
          "dependencies": [
            1,
            3
          ],
          "acceptanceCriteria": "- Assigns priorities based on multiple factors (dependencies, critical path, risk)\n- Identifies foundation/infrastructure tasks as high priority\n- Balances priorities across the project (not everything is high priority)\n- Provides justification for priority assignments\n- Allows for manual adjustment of priorities"
        },
        {
          "id": 6,
          "title": "Implement PRD Chunking for Large Documents",
          "description": "Create a system that can handle large PRDs by breaking them into manageable chunks for processing. Implement intelligent document segmentation that preserves context across chunks, tracks section relationships, and maintains coherence in the generated tasks. Develop a mechanism to reassemble and deduplicate tasks generated from different chunks into a unified task list.",
          "status": "done",
          "dependencies": [
            1,
            5,
            3
          ],
          "acceptanceCriteria": "- Successfully processes PRDs larger than Claude's context window\n- Intelligently splits documents at logical boundaries (sections, chapters)\n- Preserves context when processing individual chunks\n- Reassembles tasks from multiple chunks into a coherent task list\n- Detects and resolves duplicate or overlapping tasks\n- Maintains correct dependency relationships across chunks"
        }
      ]
    },
    {
      "id": 7,
      "title": "Implement Task Expansion with Claude",
      "description": "Create functionality to expand tasks into subtasks using Claude's AI capabilities.",
      "status": "done",
      "dependencies": [
        3,
        5
      ],
      "priority": "medium",
      "details": "Build task expansion functionality including:\n- Create subtask generation prompts\n- Implement workflow for expanding a task into subtasks\n- Add context-aware expansion capabilities\n- Implement parent-child relationship management\n- Allow specification of number of subtasks to generate\n- Provide mechanism to regenerate unsatisfactory subtasks",
      "testStrategy": "Test expanding various types of tasks into subtasks. Verify that subtasks are properly linked to parent tasks. Check that context is properly incorporated into generated subtasks.",
      "subtasks": [
        {
          "id": 1,
          "title": "Design and Implement Subtask Generation Prompts",
          "description": "Create optimized prompt templates for Claude to generate subtasks from parent tasks. Design the prompts to include task context, project information, and formatting instructions that ensure consistent, high-quality subtask generation. Implement a prompt template system that allows for dynamic insertion of task details, configurable number of subtasks, and additional context parameters.",
          "status": "done",
          "dependencies": [],
          "acceptanceCriteria": "- At least two prompt templates are created (standard and detailed)\n- Prompts include clear instructions for formatting subtask output\n- Prompts dynamically incorporate task title, description, details, and context\n- Prompts include parameters for specifying the number of subtasks to generate\n- Prompt system allows for easy modification and extension of templates"
        },
        {
          "id": 2,
          "title": "Develop Task Expansion Workflow and UI",
          "description": "Implement the command-line interface and workflow for expanding tasks into subtasks. Create a new command that allows users to select a task, specify the number of subtasks, and add optional context. Design the interaction flow to handle the API request, process the response, and update the tasks.json file with the newly generated subtasks.",
          "status": "done",
          "dependencies": [
            5
          ],
          "acceptanceCriteria": "- Command `node scripts/dev.js expand --id=<task_id> --count=<number>` is implemented\n- Optional parameters for additional context (`--context=\"...\"`) are supported\n- User is shown progress indicators during API calls\n- Generated subtasks are displayed for review before saving\n- Command handles errors gracefully with helpful error messages\n- Help documentation for the expand command is comprehensive"
        },
        {
          "id": 3,
          "title": "Implement Context-Aware Expansion Capabilities",
          "description": "Enhance the task expansion functionality to incorporate project context when generating subtasks. Develop a system to gather relevant information from the project, such as related tasks, dependencies, and previously completed work. Implement logic to include this context in the Claude prompts to improve the relevance and quality of generated subtasks.",
          "status": "done",
          "dependencies": [
            1
          ],
          "acceptanceCriteria": "- System automatically gathers context from related tasks and dependencies\n- Project metadata is incorporated into expansion prompts\n- Implementation details from dependent tasks are included in context\n- Context gathering is configurable (amount and type of context)\n- Generated subtasks show awareness of existing project structure and patterns\n- Context gathering has reasonable performance even with large task collections"
        },
        {
          "id": 4,
          "title": "Build Parent-Child Relationship Management",
          "description": "Implement the data structure and operations for managing parent-child relationships between tasks and subtasks. Create functions to establish these relationships in the tasks.json file, update the task model to support subtask arrays, and develop utilities to navigate, filter, and display task hierarchies. Ensure all basic task operations (update, delete, etc.) properly handle subtask relationships.",
          "status": "done",
          "dependencies": [
            3
          ],
          "acceptanceCriteria": "- Task model is updated to include subtasks array\n- Subtasks have proper ID format (parent.sequence)\n- Parent tasks track their subtasks with proper references\n- Task listing command shows hierarchical structure\n- Completing all subtasks automatically updates parent task status\n- Deleting a parent task properly handles orphaned subtasks\n- Task file generation includes subtask information"
        },
        {
          "id": 5,
          "title": "Implement Subtask Regeneration Mechanism",
          "description": "Create functionality that allows users to regenerate unsatisfactory subtasks. Implement a command that can target specific subtasks for regeneration, preserve satisfactory subtasks, and incorporate feedback to improve the new generation. Design the system to maintain proper parent-child relationships and task IDs during regeneration.",
          "status": "done",
          "dependencies": [
            1,
            2,
            4
          ],
          "acceptanceCriteria": "- Command `node scripts/dev.js regenerate --id=<subtask_id>` is implemented\n- Option to regenerate all subtasks for a parent (`--all`)\n- Feedback parameter allows user to guide regeneration (`--feedback=\"...\"`)\n- Original subtask details are preserved in prompt context\n- Regenerated subtasks maintain proper ID sequence\n- Task relationships remain intact after regeneration\n- Command provides clear before/after comparison of subtasks"
        }
      ]
    },
    {
      "id": 8,
      "title": "Develop Implementation Drift Handling",
      "description": "Create system to handle changes in implementation that affect future tasks.",
      "status": "done",
      "dependencies": [
        3,
        5,
        7
      ],
      "priority": "medium",
      "details": "Implement drift handling including:\n- Add capability to update future tasks based on completed work\n- Implement task rewriting based on new context\n- Create dependency chain updates when tasks change\n- Preserve completed work while updating future tasks\n- Add command to analyze and suggest updates to future tasks",
      "testStrategy": "Simulate implementation changes and test the system's ability to update future tasks appropriately. Verify that completed tasks remain unchanged while pending tasks are updated correctly.",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Task Update Mechanism Based on Completed Work",
          "description": "Implement a system that can identify pending tasks affected by recently completed tasks and update them accordingly. This requires analyzing the dependency chain and determining which future tasks need modification based on implementation decisions made in completed tasks. Create a function that takes a completed task ID as input, identifies dependent tasks, and prepares them for potential updates.",
          "status": "done",
          "dependencies": [],
          "acceptanceCriteria": "- Function implemented to identify all pending tasks that depend on a specified completed task\n- System can extract relevant implementation details from completed tasks\n- Mechanism to flag tasks that need updates based on implementation changes\n- Unit tests that verify the correct tasks are identified for updates\n- Command-line interface to trigger the update analysis process"
        },
        {
          "id": 2,
          "title": "Implement AI-Powered Task Rewriting",
          "description": "Develop functionality to use Claude API to rewrite pending tasks based on new implementation context. This involves creating specialized prompts that include the original task description, the implementation details of completed dependency tasks, and instructions to update the pending task to align with the actual implementation. The system should generate updated task descriptions, details, and test strategies.",
          "status": "done",
          "dependencies": [],
          "acceptanceCriteria": "- Specialized Claude prompt template for task rewriting\n- Function to gather relevant context from completed dependency tasks\n- Implementation of task rewriting logic that preserves task ID and dependencies\n- Proper error handling for API failures\n- Mechanism to preview changes before applying them\n- Unit tests with mock API responses"
        },
        {
          "id": 3,
          "title": "Build Dependency Chain Update System",
          "description": "Create a system to update task dependencies when task implementations change. This includes adding new dependencies that weren't initially identified, removing dependencies that are no longer relevant, and reordering dependencies based on implementation decisions. The system should maintain the integrity of the dependency graph while reflecting the actual implementation requirements.",
          "status": "done",
          "dependencies": [],
          "acceptanceCriteria": "- Function to analyze and update the dependency graph\n- Capability to add new dependencies to tasks\n- Capability to remove obsolete dependencies\n- Validation to prevent circular dependencies\n- Preservation of dependency chain integrity\n- CLI command to visualize dependency changes\n- Unit tests for dependency graph modifications"
        },
        {
          "id": 4,
          "title": "Implement Completed Work Preservation",
          "description": "Develop a mechanism to ensure that updates to future tasks don't affect completed work. This includes creating a versioning system for tasks, tracking task history, and implementing safeguards to prevent modifications to completed tasks. The system should maintain a record of task changes while ensuring that completed work remains stable.",
          "status": "done",
          "dependencies": [
            3
          ],
          "acceptanceCriteria": "- Implementation of task versioning to track changes\n- Safeguards that prevent modifications to tasks marked as \"done\"\n- System to store and retrieve task history\n- Clear visual indicators in the CLI for tasks that have been modified\n- Ability to view the original version of a modified task\n- Unit tests for completed work preservation"
        },
        {
          "id": 5,
          "title": "Create Update Analysis and Suggestion Command",
          "description": "Implement a CLI command that analyzes the current state of tasks, identifies potential drift between completed and pending tasks, and suggests updates. This command should provide a comprehensive report of potential inconsistencies and offer recommendations for task updates without automatically applying them. It should include options to apply all suggested changes, select specific changes to apply, or ignore suggestions.",
          "status": "done",
          "dependencies": [
            3
          ],
          "acceptanceCriteria": "- New CLI command \"analyze-drift\" implemented\n- Comprehensive analysis of potential implementation drift\n- Detailed report of suggested task updates\n- Interactive mode to select which suggestions to apply\n- Batch mode to apply all suggested changes\n- Option to export suggestions to a file for review\n- Documentation of the command usage and options\n- Integration tests that verify the end-to-end workflow"
        }
      ]
    },
    {
      "id": 9,
      "title": "Integrate Perplexity API",
      "description": "Add integration with Perplexity API for research-backed task generation.",
      "status": "done",
      "dependencies": [
        5
      ],
      "priority": "low",
      "details": "Implement Perplexity integration including:\n- API authentication via OpenAI client\n- Create research-oriented prompt templates\n- Implement response handling for Perplexity\n- Add fallback to Claude when Perplexity is unavailable\n- Implement response quality comparison logic\n- Add configuration for model selection",
      "testStrategy": "Test connectivity to Perplexity API. Verify research-oriented prompts return useful information. Test fallback mechanism by simulating Perplexity API unavailability.",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Perplexity API Authentication Module",
          "description": "Create a dedicated module for authenticating with the Perplexity API using the OpenAI client library. This module should handle API key management, connection setup, and basic error handling. Implement environment variable support for the PERPLEXITY_API_KEY and PERPLEXITY_MODEL variables with appropriate defaults as specified in the PRD. Include a connection test function to verify API access.",
          "status": "done",
          "dependencies": [],
          "acceptanceCriteria": "- Authentication module successfully connects to Perplexity API using OpenAI client\n- Environment variables for API key and model selection are properly handled\n- Connection test function returns appropriate success/failure responses\n- Basic error handling for authentication failures is implemented\n- Documentation for required environment variables is added to .env.example"
        },
        {
          "id": 2,
          "title": "Develop Research-Oriented Prompt Templates",
          "description": "Design and implement specialized prompt templates optimized for research tasks with Perplexity. Create a template system that can generate contextually relevant research prompts based on task information. These templates should be structured to leverage Perplexity's online search capabilities and should follow the Research-Backed Expansion Prompt Structure defined in the PRD. Include mechanisms to control prompt length and focus.",
          "status": "done",
          "dependencies": [],
          "acceptanceCriteria": "- At least 3 different research-oriented prompt templates are implemented\n- Templates can be dynamically populated with task context and parameters\n- Prompts are optimized for Perplexity's capabilities and response format\n- Template system is extensible to allow for future additions\n- Templates include appropriate system instructions to guide Perplexity's responses"
        },
        {
          "id": 3,
          "title": "Create Perplexity Response Handler",
          "description": "Implement a specialized response handler for Perplexity API responses. This should parse and process the JSON responses from Perplexity, extract relevant information, and transform it into the task data structure format. Include validation to ensure responses meet quality standards and contain the expected information. Implement streaming response handling if supported by the API client.",
          "status": "done",
          "dependencies": [],
          "acceptanceCriteria": "- Response handler successfully parses Perplexity API responses\n- Handler extracts structured task information from free-text responses\n- Validation logic identifies and handles malformed or incomplete responses\n- Response streaming is properly implemented if supported\n- Handler includes appropriate error handling for various response scenarios\n- Unit tests verify correct parsing of sample responses"
        },
        {
          "id": 4,
          "title": "Implement Claude Fallback Mechanism",
          "description": "Create a fallback system that automatically switches to the Claude API when Perplexity is unavailable or returns errors. This system should detect API failures, rate limiting, or quality issues with Perplexity responses and seamlessly transition to using Claude with appropriate prompt modifications. Implement retry logic with exponential backoff before falling back to Claude. Log all fallback events for monitoring.",
          "status": "done",
          "dependencies": [],
          "acceptanceCriteria": "- System correctly detects Perplexity API failures and availability issues\n- Fallback to Claude is triggered automatically when needed\n- Prompts are appropriately modified when switching to Claude\n- Retry logic with exponential backoff is implemented before fallback\n- All fallback events are logged with relevant details\n- Configuration option allows setting the maximum number of retries"
        },
        {
          "id": 5,
          "title": "Develop Response Quality Comparison and Model Selection",
          "description": "Implement a system to compare response quality between Perplexity and Claude, and provide configuration options for model selection. Create metrics for evaluating response quality (e.g., specificity, relevance, actionability). Add configuration options that allow users to specify which model to use for different types of tasks. Implement a caching mechanism to reduce API calls and costs when appropriate.",
          "status": "done",
          "dependencies": [],
          "acceptanceCriteria": "- Quality comparison logic evaluates responses based on defined metrics\n- Configuration system allows selection of preferred models for different operations\n- Model selection can be controlled via environment variables and command-line options\n- Response caching mechanism reduces duplicate API calls\n- System logs quality metrics for later analysis\n- Documentation clearly explains model selection options and quality metrics\n\nThese subtasks provide a comprehensive breakdown of the Perplexity API integration task, covering all the required aspects mentioned in the original task description while ensuring each subtask is specific, actionable, and technically relevant."
        }
      ]
    },
    {
      "id": 10,
      "title": "Create Research-Backed Subtask Generation",
      "description": "Enhance subtask generation with research capabilities from Perplexity API.",
      "status": "done",
      "dependencies": [
        7,
        9
      ],
      "priority": "low",
      "details": "Implement research-backed generation including:\n- Create specialized research prompts for different domains\n- Implement context enrichment from research results\n- Add domain-specific knowledge incorporation\n- Create more detailed subtask generation with best practices\n- Include references to relevant libraries and tools",
      "testStrategy": "Compare subtasks generated with and without research backing. Verify that research-backed subtasks include more specific technical details and best practices.",
      "subtasks": [
        {
          "id": 1,
          "title": "Design Domain-Specific Research Prompt Templates",
          "description": "Create a set of specialized prompt templates for different software development domains (e.g., web development, mobile, data science, DevOps). Each template should be structured to extract relevant best practices, libraries, tools, and implementation patterns from Perplexity API. Implement a prompt template selection mechanism based on the task context and domain.",
          "status": "done",
          "dependencies": [],
          "acceptanceCriteria": "- At least 5 domain-specific prompt templates are created and stored in a dedicated templates directory\n- Templates include specific sections for querying best practices, tools, libraries, and implementation patterns\n- A prompt selection function is implemented that can determine the appropriate template based on task metadata\n- Templates are parameterized to allow dynamic insertion of task details and context\n- Documentation is added explaining each template's purpose and structure"
        },
        {
          "id": 2,
          "title": "Implement Research Query Execution and Response Processing",
          "description": "Build a module that executes research queries using the Perplexity API integration. This should include sending the domain-specific prompts, handling the API responses, and parsing the results into a structured format that can be used for context enrichment. Implement error handling, rate limiting, and fallback to Claude when Perplexity is unavailable.",
          "status": "done",
          "dependencies": [],
          "acceptanceCriteria": "- Function to execute research queries with proper error handling and retries\n- Response parser that extracts structured data from Perplexity's responses\n- Fallback mechanism that uses Claude when Perplexity fails or is unavailable\n- Caching system to avoid redundant API calls for similar research queries\n- Logging system for tracking API usage and response quality\n- Unit tests verifying correct handling of successful and failed API calls"
        },
        {
          "id": 3,
          "title": "Develop Context Enrichment Pipeline",
          "description": "Create a pipeline that processes research results and enriches the task context with relevant information. This should include filtering irrelevant information, organizing research findings by category (tools, libraries, best practices, etc.), and formatting the enriched context for use in subtask generation. Implement a scoring mechanism to prioritize the most relevant research findings.",
          "status": "done",
          "dependencies": [
            2
          ],
          "acceptanceCriteria": "- Context enrichment function that takes raw research results and task details as input\n- Filtering system to remove irrelevant or low-quality information\n- Categorization of research findings into distinct sections (tools, libraries, patterns, etc.)\n- Relevance scoring algorithm to prioritize the most important findings\n- Formatted output that can be directly used in subtask generation prompts\n- Tests comparing enriched context quality against baseline"
        },
        {
          "id": 4,
          "title": "Implement Domain-Specific Knowledge Incorporation",
          "description": "Develop a system to incorporate domain-specific knowledge into the subtask generation process. This should include identifying key domain concepts, technical requirements, and industry standards from the research results. Create a knowledge base structure that organizes domain information and can be referenced during subtask generation.",
          "status": "done",
          "dependencies": [
            3
          ],
          "acceptanceCriteria": "- Domain knowledge extraction function that identifies key technical concepts\n- Knowledge base structure for organizing domain-specific information\n- Integration with the subtask generation prompt to incorporate relevant domain knowledge\n- Support for technical terminology and concept explanation in generated subtasks\n- Mechanism to link domain concepts to specific implementation recommendations\n- Tests verifying improved technical accuracy in generated subtasks"
        },
        {
          "id": 5,
          "title": "Enhance Subtask Generation with Technical Details",
          "description": "Extend the existing subtask generation functionality to incorporate research findings and produce more technically detailed subtasks. This includes modifying the Claude prompt templates to leverage the enriched context, implementing specific sections for technical approach, implementation notes, and potential challenges. Ensure generated subtasks include concrete technical details rather than generic steps.",
          "status": "done",
          "dependencies": [
            3,
            4
          ],
          "acceptanceCriteria": "- Enhanced prompt templates for Claude that incorporate research-backed context\n- Generated subtasks include specific technical approaches and implementation details\n- Each subtask contains references to relevant tools, libraries, or frameworks\n- Implementation notes section with code patterns or architectural recommendations\n- Potential challenges and mitigation strategies are included where appropriate\n- Comparative tests showing improvement over baseline subtask generation"
        },
        {
          "id": 6,
          "title": "Implement Reference and Resource Inclusion",
          "description": "Create a system to include references to relevant libraries, tools, documentation, and other resources in generated subtasks. This should extract specific references from research results, validate their relevance, and format them as actionable links or citations within subtasks. Implement a verification step to ensure referenced resources are current and applicable.",
          "status": "done",
          "dependencies": [
            3,
            5
          ],
          "acceptanceCriteria": "- Reference extraction function that identifies tools, libraries, and resources from research\n- Validation mechanism to verify reference relevance and currency\n- Formatting system for including references in subtask descriptions\n- Support for different reference types (GitHub repos, documentation, articles, etc.)\n- Optional version specification for referenced libraries and tools\n- Tests verifying that included references are relevant and accessible"
        }
      ]
    },
    {
      "id": 11,
      "title": "Implement Batch Operations",
      "description": "Add functionality for performing operations on multiple tasks simultaneously.",
      "status": "done",
      "dependencies": [
        3
      ],
      "priority": "medium",
      "details": "Create batch operations including:\n- Implement multi-task status updates\n- Add bulk subtask generation\n- Create task filtering and querying capabilities\n- Implement advanced dependency management\n- Add batch prioritization\n- Create commands for operating on filtered task sets",
      "testStrategy": "Test batch operations with various filters and operations. Verify that operations are applied correctly to all matching tasks. Test with large task sets to ensure performance.",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Multi-Task Status Update Functionality",
          "description": "Create a command-line interface command that allows users to update the status of multiple tasks simultaneously. Implement the backend logic to process batch status changes, validate the requested changes, and update the tasks.json file accordingly. The implementation should include options for filtering tasks by various criteria (ID ranges, status, priority, etc.) and applying status changes to the filtered set.",
          "status": "done",
          "dependencies": [
            3
          ],
          "acceptanceCriteria": "- Command accepts parameters for filtering tasks (e.g., `--status=pending`, `--priority=high`, `--id=1,2,3-5`)\n- Command accepts a parameter for the new status value (e.g., `--new-status=done`)\n- All matching tasks are updated in the tasks.json file\n- Command provides a summary of changes made (e.g., \"Updated 5 tasks from 'pending' to 'done'\")\n- Command handles errors gracefully (e.g., invalid status values, no matching tasks)\n- Changes are persisted correctly to tasks.json"
        },
        {
          "id": 2,
          "title": "Develop Bulk Subtask Generation System",
          "description": "Create functionality to generate multiple subtasks across several parent tasks at once. This should include a command-line interface that accepts filtering parameters to select parent tasks and either a template for subtasks or an AI-assisted generation option. The system should validate parent tasks, generate appropriate subtasks with proper ID assignments, and update the tasks.json file.",
          "status": "done",
          "dependencies": [
            3,
            4
          ],
          "acceptanceCriteria": "- Command accepts parameters for filtering parent tasks\n- Command supports template-based subtask generation with variable substitution\n- Command supports AI-assisted subtask generation using Claude API\n- Generated subtasks have proper IDs following the parent.sequence format (e.g., 1.1, 1.2)\n- Subtasks inherit appropriate properties from parent tasks (e.g., dependencies)\n- Generated subtasks are added to the tasks.json file\n- Task files are regenerated to include the new subtasks\n- Command provides a summary of subtasks created"
        },
        {
          "id": 3,
          "title": "Implement Advanced Task Filtering and Querying",
          "description": "Create a robust filtering and querying system that can be used across all batch operations. Implement a query syntax that allows for complex filtering based on task properties, including status, priority, dependencies, ID ranges, and text search within titles and descriptions. Design the system to be reusable across different batch operation commands.",
          "status": "done",
          "dependencies": [],
          "acceptanceCriteria": "- Support for filtering by task properties (status, priority, dependencies)\n- Support for ID-based filtering (individual IDs, ranges, exclusions)\n- Support for text search within titles and descriptions\n- Support for logical operators (AND, OR, NOT) in filters\n- Query parser that converts command-line arguments to filter criteria\n- Reusable filtering module that can be imported by other commands\n- Comprehensive test cases covering various filtering scenarios\n- Documentation of the query syntax for users"
        },
        {
          "id": 4,
          "title": "Create Advanced Dependency Management System",
          "description": "Implement batch operations for managing dependencies between tasks. This includes commands for adding, removing, and updating dependencies across multiple tasks simultaneously. The system should validate dependency changes to prevent circular dependencies, update the tasks.json file, and regenerate task files to reflect the changes.",
          "status": "done",
          "dependencies": [
            3
          ],
          "acceptanceCriteria": "- Command for adding dependencies to multiple tasks at once\n- Command for removing dependencies from multiple tasks\n- Command for replacing dependencies across multiple tasks\n- Validation to prevent circular dependencies\n- Validation to ensure referenced tasks exist\n- Automatic update of affected task files\n- Summary report of dependency changes made\n- Error handling for invalid dependency operations"
        },
        {
          "id": 5,
          "title": "Implement Batch Task Prioritization and Command System",
          "description": "Create a system for batch prioritization of tasks and a command framework for operating on filtered task sets. This includes commands for changing priorities of multiple tasks at once and a generic command execution system that can apply custom operations to filtered task sets. The implementation should include a plugin architecture that allows for extending the system with new batch operations.",
          "status": "done",
          "dependencies": [
            3
          ],
          "acceptanceCriteria": "- Command for changing priorities of multiple tasks at once\n- Support for relative priority changes (e.g., increase/decrease priority)\n- Generic command execution framework that works with the filtering system\n- Plugin architecture for registering new batch operations\n- At least three example plugins (e.g., batch tagging, batch assignment, batch export)\n- Command for executing arbitrary operations on filtered task sets\n- Documentation for creating new batch operation plugins\n- Performance testing with large task sets (100+ tasks)"
        }
      ]
    },
    {
      "id": 12,
      "title": "Develop Project Initialization System",
      "description": "Create functionality for initializing new projects with task structure and configuration.",
      "status": "done",
      "dependencies": [
        1,
        3,
        4,
        6
      ],
      "priority": "medium",
      "details": "Implement project initialization including:\n- Create project templating system\n- Implement interactive setup wizard\n- Add environment configuration generation\n- Create initial directory structure\n- Generate example tasks.json\n- Set up default configuration",
      "testStrategy": "Test project initialization in empty directories. Verify that all required files and directories are created correctly. Test the interactive setup with various inputs.",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Project Template Structure",
          "description": "Design and implement a flexible project template system that will serve as the foundation for new project initialization. This should include creating a base directory structure, template files (e.g., default tasks.json, .env.example), and a configuration file to define customizable aspects of the template.",
          "status": "done",
          "dependencies": [
            4
          ],
          "acceptanceCriteria": "- A `templates` directory is created with at least one default project template"
        },
        {
          "id": 2,
          "title": "Implement Interactive Setup Wizard",
          "description": "Develop an interactive command-line wizard using a library like Inquirer.js to guide users through the project initialization process. The wizard should prompt for project name, description, initial task structure, and other configurable options defined in the template configuration.",
          "status": "done",
          "dependencies": [
            3
          ],
          "acceptanceCriteria": "- Interactive wizard prompts for essential project information"
        },
        {
          "id": 3,
          "title": "Generate Environment Configuration",
          "description": "Create functionality to generate environment-specific configuration files based on user input and template defaults. This includes creating a .env file with necessary API keys and configuration values, and updating the tasks.json file with project-specific metadata.",
          "status": "done",
          "dependencies": [
            2
          ],
          "acceptanceCriteria": "- .env file is generated with placeholders for required API keys"
        },
        {
          "id": 4,
          "title": "Implement Directory Structure Creation",
          "description": "Develop the logic to create the initial directory structure for new projects based on the selected template and user inputs. This should include creating necessary subdirectories (e.g., tasks/, scripts/, .cursor/rules/) and copying template files to appropriate locations.",
          "status": "done",
          "dependencies": [
            1
          ],
          "acceptanceCriteria": "- Directory structure is created according to the template specification"
        },
        {
          "id": 5,
          "title": "Generate Example Tasks.json",
          "description": "Create functionality to generate an initial tasks.json file with example tasks based on the project template and user inputs from the setup wizard. This should include creating a set of starter tasks that demonstrate the task structure and provide a starting point for the project.",
          "status": "done",
          "dependencies": [
            6
          ],
          "acceptanceCriteria": "- An initial tasks.json file is generated with at least 3 example tasks"
        },
        {
          "id": 6,
          "title": "Implement Default Configuration Setup",
          "description": "Develop the system for setting up default configurations for the project, including initializing the .cursor/rules/ directory with dev_workflow.mdc, cursor_rules.mdc, and self_improve.mdc files. Also, create a default package.json with necessary dependencies and scripts for the project.",
          "status": "done",
          "dependencies": [],
          "acceptanceCriteria": "- .cursor/rules/ directory is created with required .mdc files"
        }
      ]
    },
    {
      "id": 13,
      "title": "Create Cursor Rules Implementation",
      "description": "Develop the Cursor AI integration rules and documentation.",
      "status": "done",
      "dependencies": [
        1,
        3
      ],
      "priority": "medium",
      "details": "Implement Cursor rules including:\n- Create dev_workflow.mdc documentation\n- Implement cursor_rules.mdc\n- Add self_improve.mdc\n- Design rule integration documentation\n- Set up .cursor directory structure\n- Document how Cursor AI should interact with the system",
      "testStrategy": "Review rules documentation for clarity and completeness. Test with Cursor AI to verify the rules are properly interpreted and followed.",
      "subtasks": [
        {
          "id": 1,
          "title": "Set up .cursor Directory Structure",
          "description": "Create the required directory structure for Cursor AI integration, including the .cursor folder and rules subfolder. This provides the foundation for storing all Cursor-related configuration files and rule documentation. Ensure proper permissions and gitignore settings are configured to maintain these files correctly.",
          "status": "done",
          "dependencies": [],
          "acceptanceCriteria": "- .cursor directory created at the project root\n- .cursor/rules subdirectory created\n- Directory structure matches the specification in the PRD\n- Appropriate entries added to .gitignore to handle .cursor directory correctly\n- README documentation updated to mention the .cursor directory purpose"
        },
        {
          "id": 2,
          "title": "Create dev_workflow.mdc Documentation",
          "description": "Develop the dev_workflow.mdc file that documents the development workflow for Cursor AI. This file should outline how Cursor AI should assist with task discovery, implementation, and verification within the project. Include specific examples of commands and interactions that demonstrate the optimal workflow.",
          "status": "done",
          "dependencies": [
            1
          ],
          "acceptanceCriteria": "- dev_workflow.mdc file created in .cursor/rules directory\n- Document clearly explains the development workflow with Cursor AI\n- Workflow documentation includes task discovery process\n- Implementation guidance for Cursor AI is detailed\n- Verification procedures are documented\n- Examples of typical interactions are provided"
        },
        {
          "id": 3,
          "title": "Implement cursor_rules.mdc",
          "description": "Create the cursor_rules.mdc file that defines specific rules and guidelines for how Cursor AI should interact with the codebase. This should include code style preferences, architectural patterns to follow, documentation requirements, and any project-specific conventions that Cursor AI should adhere to when generating or modifying code.",
          "status": "done",
          "dependencies": [
            1
          ],
          "acceptanceCriteria": "- cursor_rules.mdc file created in .cursor/rules directory\n- Rules document clearly defines code style guidelines\n- Architectural patterns and principles are specified\n- Documentation requirements for generated code are outlined\n- Project-specific naming conventions are documented\n- Rules for handling dependencies and imports are defined\n- Guidelines for test implementation are included"
        },
        {
          "id": 4,
          "title": "Add self_improve.mdc Documentation",
          "description": "Develop the self_improve.mdc file that instructs Cursor AI on how to continuously improve its assistance capabilities within the project context. This document should outline how Cursor AI should learn from feedback, adapt to project evolution, and enhance its understanding of the codebase over time.",
          "status": "done",
          "dependencies": [
            1,
            2,
            3
          ],
          "acceptanceCriteria": "- self_improve.mdc file created in .cursor/rules directory\n- Document outlines feedback incorporation mechanisms\n- Guidelines for adapting to project evolution are included\n- Instructions for enhancing codebase understanding over time\n- Strategies for improving code suggestions based on past interactions\n- Methods for refining prompt responses based on user feedback\n- Approach for maintaining consistency with evolving project patterns"
        },
        {
          "id": 5,
          "title": "Create Cursor AI Integration Documentation",
          "description": "Develop comprehensive documentation on how Cursor AI integrates with the task management system. This should include detailed instructions on how Cursor AI should interpret tasks.json, individual task files, and how it should assist with implementation. Document the specific commands and workflows that Cursor AI should understand and support.",
          "status": "done",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "acceptanceCriteria": "- Integration documentation created and stored in an appropriate location\n- Documentation explains how Cursor AI should interpret tasks.json structure\n- Guidelines for Cursor AI to understand task dependencies and priorities\n- Instructions for Cursor AI to assist with task implementation\n- Documentation of specific commands Cursor AI should recognize\n- Examples of effective prompts for working with the task system\n- Troubleshooting section for common Cursor AI integration issues\n- Documentation references all created rule files and explains their purpose"
        }
      ]
    },
    {
      "id": 14,
      "title": "Develop Agent Workflow Guidelines",
      "description": "Create comprehensive guidelines for how AI agents should interact with the task system.",
      "status": "done",
      "dependencies": [
        13
      ],
      "priority": "medium",
      "details": "Create agent workflow guidelines including:\n- Document task discovery workflow\n- Create task selection guidelines\n- Implement implementation guidance\n- Add verification procedures\n- Define how agents should prioritize work\n- Create guidelines for handling dependencies",
      "testStrategy": "Review guidelines with actual AI agents to verify they can follow the procedures. Test various scenarios to ensure the guidelines cover all common workflows.",
      "subtasks": [
        {
          "id": 1,
          "title": "Document Task Discovery Workflow",
          "description": "Create a comprehensive document outlining how AI agents should discover and interpret new tasks within the system. This should include steps for parsing the tasks.json file, interpreting task metadata, and understanding the relationships between tasks and subtasks. Implement example code snippets in Node.js demonstrating how to traverse the task structure and extract relevant information.",
          "status": "done",
          "dependencies": [],
          "acceptanceCriteria": "- Detailed markdown document explaining the task discovery process"
        },
        {
          "id": 2,
          "title": "Implement Task Selection Algorithm",
          "description": "Develop an algorithm for AI agents to select the most appropriate task to work on based on priority, dependencies, and current project status. This should include logic for evaluating task urgency, managing blocked tasks, and optimizing workflow efficiency. Implement the algorithm in JavaScript and integrate it with the existing task management system.",
          "status": "done",
          "dependencies": [
            1
          ],
          "acceptanceCriteria": "- JavaScript module implementing the task selection algorithm"
        },
        {
          "id": 3,
          "title": "Create Implementation Guidance Generator",
          "description": "Develop a system that generates detailed implementation guidance for AI agents based on task descriptions and project context. This should leverage the Anthropic Claude API to create step-by-step instructions, suggest relevant libraries or tools, and provide code snippets or pseudocode where appropriate. Implement caching to reduce API calls and improve performance.",
          "status": "done",
          "dependencies": [
            5
          ],
          "acceptanceCriteria": "- Node.js module for generating implementation guidance using Claude API"
        },
        {
          "id": 4,
          "title": "Develop Verification Procedure Framework",
          "description": "Create a flexible framework for defining and executing verification procedures for completed tasks. This should include a DSL (Domain Specific Language) for specifying acceptance criteria, automated test generation where possible, and integration with popular testing frameworks. Implement hooks for both automated and manual verification steps.",
          "status": "done",
          "dependencies": [
            1,
            2
          ],
          "acceptanceCriteria": "- JavaScript module implementing the verification procedure framework"
        },
        {
          "id": 5,
          "title": "Implement Dynamic Task Prioritization System",
          "description": "Develop a system that dynamically adjusts task priorities based on project progress, dependencies, and external factors. This should include an algorithm for recalculating priorities, a mechanism for propagating priority changes through dependency chains, and an API for external systems to influence priorities. Implement this as a background process that periodically updates the tasks.json file.",
          "status": "done",
          "dependencies": [
            1,
            2,
            3
          ],
          "acceptanceCriteria": "- Node.js module implementing the dynamic prioritization system"
        }
      ]
    },
    {
      "id": 15,
      "title": "Optimize Agent Integration with Cursor and dev.js Commands",
      "description": "Document and enhance existing agent interaction patterns through Cursor rules and dev.js commands.",
      "status": "done",
      "dependencies": [
        14
      ],
      "priority": "medium",
      "details": "Optimize agent integration including:\n- Document and improve existing agent interaction patterns in Cursor rules\n- Enhance integration between Cursor agent capabilities and dev.js commands\n- Improve agent workflow documentation in cursor rules (dev_workflow.mdc, cursor_rules.mdc)\n- Add missing agent-specific features to existing commands\n- Leverage existing infrastructure rather than building a separate system",
      "testStrategy": "Test the enhanced commands with AI agents to verify they can correctly interpret and use them. Verify that agents can effectively interact with the task system using the documented patterns in Cursor rules.",
      "subtasks": [
        {
          "id": 1,
          "title": "Document Existing Agent Interaction Patterns",
          "description": "Review and document the current agent interaction patterns in Cursor rules (dev_workflow.mdc, cursor_rules.mdc). Create comprehensive documentation that explains how agents should interact with the task system using existing commands and patterns.",
          "status": "done",
          "dependencies": [],
          "acceptanceCriteria": "- Comprehensive documentation of existing agent interaction patterns in Cursor rules"
        },
        {
          "id": 2,
          "title": "Enhance Integration Between Cursor Agents and dev.js Commands",
          "description": "Improve the integration between Cursor's built-in agent capabilities and the dev.js command system. Ensure that agents can effectively use all task management commands and that the command outputs are optimized for agent consumption.",
          "status": "done",
          "dependencies": [],
          "acceptanceCriteria": "- Enhanced integration between Cursor agents and dev.js commands"
        },
        {
          "id": 3,
          "title": "Optimize Command Responses for Agent Consumption",
          "description": "Refine the output format of existing commands to ensure they are easily parseable by AI agents. Focus on consistent, structured outputs that agents can reliably interpret without requiring a separate parsing system.",
          "status": "done",
          "dependencies": [
            2
          ],
          "acceptanceCriteria": "- Command outputs optimized for agent consumption"
        },
        {
          "id": 4,
          "title": "Improve Agent Workflow Documentation in Cursor Rules",
          "description": "Enhance the agent workflow documentation in dev_workflow.mdc and cursor_rules.mdc to provide clear guidance on how agents should interact with the task system. Include example interactions and best practices for agents.",
          "status": "done",
          "dependencies": [
            1,
            3
          ],
          "acceptanceCriteria": "- Enhanced agent workflow documentation in Cursor rules"
        },
        {
          "id": 5,
          "title": "Add Agent-Specific Features to Existing Commands",
          "description": "Identify and implement any missing agent-specific features in the existing command system. This may include additional flags, parameters, or output formats that are particularly useful for agent interactions.",
          "status": "done",
          "dependencies": [
            2
          ],
          "acceptanceCriteria": "- Agent-specific features added to existing commands"
        },
        {
          "id": 6,
          "title": "Create Agent Usage Examples and Patterns",
          "description": "Develop a set of example interactions and usage patterns that demonstrate how agents should effectively use the task system. Include these examples in the documentation to guide future agent implementations.",
          "status": "done",
          "dependencies": [
            3,
            4
          ],
          "acceptanceCriteria": "- Comprehensive set of agent usage examples and patterns"
        }
      ]
    },
    {
      "id": 16,
      "title": "Create Configuration Management System",
      "description": "Implement robust configuration handling with environment variables and .env files.",
      "status": "done",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "Build configuration management including:\n- Environment variable handling\n- .env file support\n- Configuration validation\n- Sensible defaults with overrides\n- Create .env.example template\n- Add configuration documentation\n- Implement secure handling of API keys",
      "testStrategy": "Test configuration loading from various sources (environment variables, .env files). Verify that validation correctly identifies invalid configurations. Test that defaults are applied when values are missing.",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Environment Variable Loading",
          "description": "Create a module that loads environment variables from process.env and makes them accessible throughout the application. Implement a hierarchical structure for configuration values with proper typing. Include support for required vs. optional variables and implement a validation mechanism to ensure critical environment variables are present.",
          "status": "done",
          "dependencies": [],
          "acceptanceCriteria": "- Function created to access environment variables with proper TypeScript typing\n- Support for required variables with validation\n- Default values provided for optional variables\n- Error handling for missing required variables\n- Unit tests verifying environment variable loading works correctly"
        },
        {
          "id": 2,
          "title": "Implement .env File Support",
          "description": "Add support for loading configuration from .env files using dotenv or a similar library. Implement file detection, parsing, and merging with existing environment variables. Handle multiple environments (.env.development, .env.production, etc.) and implement proper error handling for file reading issues.",
          "status": "done",
          "dependencies": [
            1
          ],
          "acceptanceCriteria": "- Integration with dotenv or equivalent library\n- Support for multiple environment-specific .env files (.env.development, .env.production)\n- Proper error handling for missing or malformed .env files\n- Priority order established (process.env overrides .env values)\n- Unit tests verifying .env file loading and overriding behavior"
        },
        {
          "id": 3,
          "title": "Implement Configuration Validation",
          "description": "Create a validation system for configuration values using a schema validation library like Joi, Zod, or Ajv. Define schemas for all configuration categories (API keys, file paths, feature flags, etc.). Implement validation that runs at startup and provides clear error messages for invalid configurations.",
          "status": "done",
          "dependencies": [
            1,
            2
          ],
          "acceptanceCriteria": "- Schema validation implemented for all configuration values\n- Type checking and format validation for different value types\n- Comprehensive error messages that clearly identify validation failures\n- Support for custom validation rules for complex configuration requirements\n- Unit tests covering validation of valid and invalid configurations"
        },
        {
          "id": 4,
          "title": "Create Configuration Defaults and Override System",
          "description": "Implement a system of sensible defaults for all configuration values with the ability to override them via environment variables or .env files. Create a unified configuration object that combines defaults, .env values, and environment variables with proper precedence. Implement a caching mechanism to avoid repeated environment lookups.",
          "status": "done",
          "dependencies": [
            1,
            2,
            3
          ],
          "acceptanceCriteria": "- Default configuration values defined for all settings\n- Clear override precedence (env vars > .env files > defaults)\n- Configuration object accessible throughout the application\n- Caching mechanism to improve performance\n- Unit tests verifying override behavior works correctly"
        },
        {
          "id": 5,
          "title": "Create .env.example Template",
          "description": "Generate a comprehensive .env.example file that documents all supported environment variables, their purpose, format, and default values. Include comments explaining the purpose of each variable and provide examples. Ensure sensitive values are not included but have clear placeholders.",
          "status": "done",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "acceptanceCriteria": "- Complete .env.example file with all supported variables\n- Detailed comments explaining each variable's purpose and format\n- Clear placeholders for sensitive values (API_KEY=your-api-key-here)\n- Categorization of variables by function (API, logging, features, etc.)\n- Documentation on how to use the .env.example file"
        },
        {
          "id": 6,
          "title": "Implement Secure API Key Handling",
          "description": "Create a secure mechanism for handling sensitive configuration values like API keys. Implement masking of sensitive values in logs and error messages. Add validation for API key formats and implement a mechanism to detect and warn about insecure storage of API keys (e.g., committed to git). Add support for key rotation and refresh.",
          "status": "done",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "acceptanceCriteria": "- Secure storage of API keys and sensitive configuration\n- Masking of sensitive values in logs and error messages\n- Validation of API key formats (length, character set, etc.)\n- Warning system for potentially insecure configuration practices\n- Support for key rotation without application restart\n- Unit tests verifying secure handling of sensitive configuration\n\nThese subtasks provide a comprehensive approach to implementing the configuration management system with a focus on security, validation, and developer experience. The tasks are sequenced to build upon each other logically, starting with basic environment variable support and progressing to more advanced features like secure API key handling."
        }
      ]
    },
    {
      "id": 17,
      "title": "Implement Comprehensive Logging System",
      "description": "Create a flexible logging system with configurable levels and output formats.",
      "status": "done",
      "dependencies": [
        16
      ],
      "priority": "medium",
      "details": "Implement logging system including:\n- Multiple log levels (debug, info, warn, error)\n- Configurable output destinations\n- Command execution logging\n- API interaction logging\n- Error tracking\n- Performance metrics\n- Log file rotation",
      "testStrategy": "Test logging at different verbosity levels. Verify that logs contain appropriate information for debugging. Test log file rotation with large volumes of logs.",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Core Logging Framework with Log Levels",
          "description": "Create a modular logging framework that supports multiple log levels (debug, info, warn, error). Implement a Logger class that handles message formatting, timestamp addition, and log level filtering. The framework should allow for global log level configuration through the configuration system and provide a clean API for logging messages at different levels.",
          "status": "done",
          "dependencies": [],
          "acceptanceCriteria": "- Logger class with methods for each log level (debug, info, warn, error)\n- Log level filtering based on configuration settings\n- Consistent log message format including timestamp, level, and context\n- Unit tests for each log level and filtering functionality\n- Documentation for logger usage in different parts of the application"
        },
        {
          "id": 2,
          "title": "Implement Configurable Output Destinations",
          "description": "Extend the logging framework to support multiple output destinations simultaneously. Implement adapters for console output, file output, and potentially other destinations (like remote logging services). Create a configuration system that allows specifying which log levels go to which destinations. Ensure thread-safe writing to prevent log corruption.",
          "status": "done",
          "dependencies": [
            1
          ],
          "acceptanceCriteria": "- Abstract destination interface that can be implemented by different output types\n- Console output adapter with color-coding based on log level\n- File output adapter with proper file handling and path configuration\n- Configuration options to route specific log levels to specific destinations\n- Ability to add custom output destinations through the adapter pattern\n- Tests verifying logs are correctly routed to configured destinations"
        },
        {
          "id": 3,
          "title": "Implement Command and API Interaction Logging",
          "description": "Create specialized logging functionality for command execution and API interactions. For commands, log the command name, arguments, options, and execution status. For API interactions, log request details (URL, method, headers), response status, and timing information. Implement sanitization to prevent logging sensitive data like API keys or passwords.",
          "status": "done",
          "dependencies": [
            1,
            2
          ],
          "acceptanceCriteria": "- Command logger that captures command execution details\n- API logger that records request/response details with timing information\n- Data sanitization to mask sensitive information in logs\n- Configuration options to control verbosity of command and API logs\n- Integration with existing command execution flow\n- Tests verifying proper logging of commands and API calls"
        },
        {
          "id": 4,
          "title": "Implement Error Tracking and Performance Metrics",
          "description": "Enhance the logging system to provide detailed error tracking and performance metrics. For errors, capture stack traces, error codes, and contextual information. For performance metrics, implement timing utilities to measure execution duration of key operations. Create a consistent format for these specialized log types to enable easier analysis.",
          "status": "done",
          "dependencies": [
            1
          ],
          "acceptanceCriteria": "- Error logging with full stack trace capture and error context\n- Performance timer utility for measuring operation duration\n- Standard format for error and performance log entries\n- Ability to track related errors through correlation IDs\n- Configuration options for performance logging thresholds\n- Unit tests for error tracking and performance measurement"
        },
        {
          "id": 5,
          "title": "Implement Log File Rotation and Management",
          "description": "Create a log file management system that handles rotation based on file size or time intervals. Implement compression of rotated logs, automatic cleanup of old logs, and configurable retention policies. Ensure that log rotation happens without disrupting the application and that no log messages are lost during rotation.",
          "status": "done",
          "dependencies": [
            2
          ],
          "acceptanceCriteria": "- Log rotation based on configurable file size or time interval\n- Compressed archive creation for rotated logs\n- Configurable retention policy for log archives\n- Zero message loss during rotation operations\n- Proper file locking to prevent corruption during rotation\n- Configuration options for rotation settings\n- Tests verifying rotation functionality with large log volumes\n- Documentation for log file location and naming conventions"
        }
      ]
    },
    {
      "id": 18,
      "title": "Create Comprehensive User Documentation",
      "description": "Develop complete user documentation including README, examples, and troubleshooting guides.",
      "status": "done",
      "dependencies": [
        1,
        3,
        4,
        5,
        6,
        7,
        11,
        12,
        16
      ],
      "priority": "medium",
      "details": "Create user documentation including:\n- Detailed README with installation and usage instructions\n- Command reference documentation\n- Configuration guide\n- Example workflows\n- Troubleshooting guides\n- API integration documentation\n- Best practices\n- Advanced usage scenarios",
      "testStrategy": "Review documentation for clarity and completeness. Have users unfamiliar with the system attempt to follow the documentation and note any confusion or issues.",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Detailed README with Installation and Usage Instructions",
          "description": "Develop a comprehensive README.md file that serves as the primary documentation entry point. Include project overview, installation steps for different environments, basic usage examples, and links to other documentation sections. Structure the README with clear headings, code blocks for commands, and screenshots where helpful.",
          "status": "done",
          "dependencies": [
            3
          ],
          "acceptanceCriteria": "- README includes project overview, features list, and system requirements\n- Installation instructions cover all supported platforms with step-by-step commands\n- Basic usage examples demonstrate core functionality with command syntax\n- Configuration section explains environment variables and .env file usage\n- Documentation includes badges for version, license, and build status\n- All sections are properly formatted with Markdown for readability"
        },
        {
          "id": 2,
          "title": "Develop Command Reference Documentation",
          "description": "Create detailed documentation for all CLI commands, their options, arguments, and examples. Organize commands by functionality category, include syntax diagrams, and provide real-world examples for each command. Document all global options and environment variables that affect command behavior.",
          "status": "done",
          "dependencies": [
            3
          ],
          "acceptanceCriteria": "- All commands are documented with syntax, options, and arguments\n- Each command includes at least 2 practical usage examples\n- Commands are organized into logical categories (task management, AI integration, etc.)\n- Global options are documented with their effects on command execution\n- Exit codes and error messages are documented for troubleshooting\n- Documentation includes command output examples"
        },
        {
          "id": 3,
          "title": "Create Configuration and Environment Setup Guide",
          "description": "Develop a comprehensive guide for configuring the application, including environment variables, .env file setup, API keys management, and configuration best practices. Include security considerations for API keys and sensitive information. Document all configuration options with their default values and effects.",
          "status": "done",
          "dependencies": [],
          "acceptanceCriteria": "- All environment variables are documented with purpose, format, and default values\n- Step-by-step guide for setting up .env file with examples\n- Security best practices for managing API keys\n- Configuration troubleshooting section with common issues and solutions\n- Documentation includes example configurations for different use cases\n- Validation rules for configuration values are clearly explained"
        },
        {
          "id": 4,
          "title": "Develop Example Workflows and Use Cases",
          "description": "Create detailed documentation of common workflows and use cases, showing how to use the tool effectively for different scenarios. Include step-by-step guides with command sequences, expected outputs, and explanations. Cover basic to advanced workflows, including PRD parsing, task expansion, and implementation drift handling.",
          "status": "done",
          "dependencies": [
            3,
            6
          ],
          "acceptanceCriteria": "- At least 5 complete workflow examples from initialization to completion\n- Each workflow includes all commands in sequence with expected outputs\n- Screenshots or terminal recordings illustrate the workflows\n- Explanation of decision points and alternatives within workflows\n- Advanced use cases demonstrate integration with development processes\n- Examples show how to handle common edge cases and errors"
        },
        {
          "id": 5,
          "title": "Create Troubleshooting Guide and FAQ",
          "description": "Develop a comprehensive troubleshooting guide that addresses common issues, error messages, and their solutions. Include a FAQ section covering common questions about usage, configuration, and best practices. Document known limitations and workarounds for edge cases.",
          "status": "done",
          "dependencies": [
            1,
            2,
            3
          ],
          "acceptanceCriteria": "- All error messages are documented with causes and solutions\n- Common issues are organized by category (installation, configuration, execution)\n- FAQ covers at least 15 common questions with detailed answers\n- Troubleshooting decision trees help users diagnose complex issues\n- Known limitations and edge cases are clearly documented\n- Recovery procedures for data corruption or API failures are included"
        },
        {
          "id": 6,
          "title": "Develop API Integration and Extension Documentation",
          "description": "Create technical documentation for API integrations (Claude, Perplexity) and extension points. Include details on prompt templates, response handling, token optimization, and custom integrations. Document the internal architecture to help developers extend the tool with new features or integrations.",
          "status": "done",
          "dependencies": [
            5
          ],
          "acceptanceCriteria": "- Detailed documentation of all API integrations with authentication requirements\n- Prompt templates are documented with variables and expected responses\n- Token usage optimization strategies are explained\n- Extension points are documented with examples\n- Internal architecture diagrams show component relationships\n- Custom integration guide includes step-by-step instructions and code examples"
        }
      ]
    },
    {
      "id": 19,
      "title": "Implement Error Handling and Recovery",
      "description": "Create robust error handling throughout the system with helpful error messages and recovery options.",
      "status": "done",
      "dependencies": [
        1,
        3,
        5,
        9,
        16,
        17
      ],
      "priority": "high",
      "details": "Implement error handling including:\n- Consistent error message format\n- Helpful error messages with recovery suggestions\n- API error handling with retries\n- File system error recovery\n- Data validation errors with specific feedback\n- Command syntax error guidance\n- System state recovery after failures",
      "testStrategy": "Deliberately trigger various error conditions and verify that the system handles them gracefully. Check that error messages are helpful and provide clear guidance on how to resolve issues.",
      "subtasks": [
        {
          "id": 1,
          "title": "Define Error Message Format and Structure",
          "description": "Create a standardized error message format that includes error codes, descriptive messages, and recovery suggestions. Implement a centralized ErrorMessage class or module that enforces this structure across the application. This should include methods for generating consistent error messages and translating error codes to user-friendly descriptions.",
          "status": "done",
          "dependencies": [],
          "acceptanceCriteria": "- ErrorMessage class/module is implemented with methods for creating structured error messages"
        },
        {
          "id": 2,
          "title": "Implement API Error Handling with Retry Logic",
          "description": "Develop a robust error handling system for API calls, including automatic retries with exponential backoff. Create a wrapper for API requests that catches common errors (e.g., network timeouts, rate limiting) and implements appropriate retry logic. This should be integrated with both the Claude and Perplexity API calls.",
          "status": "done",
          "dependencies": [],
          "acceptanceCriteria": "- API request wrapper is implemented with configurable retry logic"
        },
        {
          "id": 3,
          "title": "Develop File System Error Recovery Mechanisms",
          "description": "Implement error handling and recovery mechanisms for file system operations, focusing on tasks.json and individual task files. This should include handling of file not found errors, permission issues, and data corruption scenarios. Implement automatic backups and recovery procedures to ensure data integrity.",
          "status": "done",
          "dependencies": [
            1
          ],
          "acceptanceCriteria": "- File system operations are wrapped with comprehensive error handling"
        },
        {
          "id": 4,
          "title": "Enhance Data Validation with Detailed Error Feedback",
          "description": "Improve the existing data validation system to provide more specific and actionable error messages. Implement detailed validation checks for all user inputs and task data, with clear error messages that pinpoint the exact issue and how to resolve it. This should cover task creation, updates, and any data imported from external sources.",
          "status": "done",
          "dependencies": [
            1,
            3
          ],
          "acceptanceCriteria": "- Enhanced validation checks are implemented for all task properties and user inputs"
        },
        {
          "id": 5,
          "title": "Implement Command Syntax Error Handling and Guidance",
          "description": "Enhance the CLI to provide more helpful error messages and guidance when users input invalid commands or options. Implement a \"did you mean?\" feature for close matches to valid commands, and provide context-sensitive help for command syntax errors. This should integrate with the existing Commander.js setup.",
          "status": "done",
          "dependencies": [
            2
          ],
          "acceptanceCriteria": "- Invalid commands trigger helpful error messages with suggestions for valid alternatives"
        },
        {
          "id": 6,
          "title": "Develop System State Recovery After Critical Failures",
          "description": "Implement a system state recovery mechanism to handle critical failures that could leave the task management system in an inconsistent state. This should include creating periodic snapshots of the system state, implementing a recovery procedure to restore from these snapshots, and providing tools for manual intervention if automatic recovery fails.",
          "status": "done",
          "dependencies": [
            1,
            3
          ],
          "acceptanceCriteria": "- Periodic snapshots of the tasks.json and related state are automatically created"
        }
      ]
    },
    {
      "id": 20,
      "title": "Create Token Usage Tracking and Cost Management",
      "description": "Implement system for tracking API token usage and managing costs.",
      "status": "done",
      "dependencies": [
        5,
        9,
        17
      ],
      "priority": "medium",
      "details": "Implement token tracking including:\n- Track token usage for all API calls\n- Implement configurable usage limits\n- Add reporting on token consumption\n- Create cost estimation features\n- Implement caching to reduce API calls\n- Add token optimization for prompts\n- Create usage alerts when approaching limits",
      "testStrategy": "Track token usage across various operations and verify accuracy. Test that limits properly prevent excessive usage. Verify that caching reduces token consumption for repeated operations.",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Token Usage Tracking for API Calls",
          "description": "Create a middleware or wrapper function that intercepts all API calls to OpenAI, Anthropic, and Perplexity. This function should count the number of tokens used in both the request and response, storing this information in a persistent data store (e.g., SQLite database). Implement a caching mechanism to reduce redundant API calls and token usage.",
          "status": "done",
          "dependencies": [
            5
          ],
          "acceptanceCriteria": "- Token usage is accurately tracked for all API calls"
        },
        {
          "id": 2,
          "title": "Develop Configurable Usage Limits",
          "description": "Create a configuration system that allows setting token usage limits at the project, user, and API level. Implement a mechanism to enforce these limits by checking the current usage against the configured limits before making API calls. Add the ability to set different limit types (e.g., daily, weekly, monthly) and actions to take when limits are reached (e.g., block calls, send notifications).",
          "status": "done",
          "dependencies": [],
          "acceptanceCriteria": "- Configuration file or database table for storing usage limits"
        },
        {
          "id": 3,
          "title": "Implement Token Usage Reporting and Cost Estimation",
          "description": "Develop a reporting module that generates detailed token usage reports. Include breakdowns by API, user, and time period. Implement cost estimation features by integrating current pricing information for each API. Create both command-line and programmatic interfaces for generating reports and estimates.",
          "status": "done",
          "dependencies": [
            1,
            2
          ],
          "acceptanceCriteria": "- CLI command for generating usage reports with various filters"
        },
        {
          "id": 4,
          "title": "Optimize Token Usage in Prompts",
          "description": "Implement a prompt optimization system that analyzes and refines prompts to reduce token usage while maintaining effectiveness. Use techniques such as prompt compression, removing redundant information, and leveraging efficient prompting patterns. Integrate this system into the existing prompt generation and API call processes.",
          "status": "done",
          "dependencies": [],
          "acceptanceCriteria": "- Prompt optimization function reduces average token usage by at least 10%"
        },
        {
          "id": 5,
          "title": "Develop Token Usage Alert System",
          "description": "Create an alert system that monitors token usage in real-time and sends notifications when usage approaches or exceeds defined thresholds. Implement multiple notification channels (e.g., email, Slack, system logs) and allow for customizable alert rules. Integrate this system with the existing logging and reporting modules.",
          "status": "done",
          "dependencies": [
            2,
            3
          ],
          "acceptanceCriteria": "- Real-time monitoring of token usage against configured limits"
        }
      ]
    },
    {
      "id": 21,
      "title": "Refactor dev.js into Modular Components",
      "description": "Restructure the monolithic dev.js file into separate modular components to improve code maintainability, readability, and testability while preserving all existing functionality.",
      "status": "done",
      "dependencies": [
        3,
        16,
        17
      ],
      "priority": "high",
      "details": "This task involves breaking down the current dev.js file into logical modules with clear responsibilities:\n\n1. Create the following module files:\n   - commands.js: Handle all CLI command definitions and execution logic\n   - ai-services.js: Encapsulate all AI service interactions (OpenAI, etc.)\n   - task-manager.js: Manage task operations (create, read, update, delete)\n   - ui.js: Handle all console output formatting, colors, and user interaction\n   - utils.js: Contain helper functions, utilities, and shared code\n\n2. Refactor dev.js to serve as the entry point that:\n   - Imports and initializes all modules\n   - Handles command-line argument parsing\n   - Sets up the execution environment\n   - Orchestrates the flow between modules\n\n3. Ensure proper dependency injection between modules to avoid circular dependencies\n\n4. Maintain consistent error handling across modules\n\n5. Update import/export statements throughout the codebase\n\n6. Document each module with clear JSDoc comments explaining purpose and usage\n\n7. Ensure configuration and logging systems are properly integrated into each module\n\nThe refactoring should not change any existing functionality - this is purely a code organization task.",
      "testStrategy": "Testing should verify that functionality remains identical after refactoring:\n\n1. Automated Testing:\n   - Create unit tests for each new module to verify individual functionality\n   - Implement integration tests that verify modules work together correctly\n   - Test each command to ensure it works exactly as before\n\n2. Manual Testing:\n   - Execute all existing CLI commands and verify outputs match pre-refactoring behavior\n   - Test edge cases like error handling and invalid inputs\n   - Verify that configuration options still work as expected\n\n3. Code Quality Verification:\n   - Run linting tools to ensure code quality standards are maintained\n   - Check for any circular dependencies between modules\n   - Verify that each module has a single, clear responsibility\n\n4. Performance Testing:\n   - Compare execution time before and after refactoring to ensure no performance regression\n\n5. Documentation Check:\n   - Verify that each module has proper documentation\n   - Ensure README is updated if necessary to reflect architectural changes",
      "subtasks": [
        {
          "id": 1,
          "title": "Analyze Current dev.js Structure and Plan Module Boundaries",
          "description": "Perform a comprehensive analysis of the existing dev.js file to identify logical boundaries for the new modules. Create a detailed mapping document that outlines which functions, variables, and code blocks will move to which module files. Identify shared dependencies, potential circular references, and determine the appropriate interfaces between modules.",
          "status": "done",
          "dependencies": [],
          "acceptanceCriteria": "- Complete inventory of all functions, variables, and code blocks in dev.js"
        },
        {
          "id": 2,
          "title": "Create Core Module Structure and Entry Point Refactoring",
          "description": "Create the skeleton structure for all module files (commands.js, ai-services.js, task-manager.js, ui.js, utils.js) with proper export statements. Refactor dev.js to serve as the entry point that imports and orchestrates these modules. Implement the basic initialization flow and command-line argument parsing in the new structure.",
          "status": "done",
          "dependencies": [
            1
          ],
          "acceptanceCriteria": "- All module files created with appropriate JSDoc headers explaining purpose"
        },
        {
          "id": 3,
          "title": "Implement Core Module Functionality with Dependency Injection",
          "description": "Migrate the core functionality from dev.js into the appropriate modules following the mapping document. Implement proper dependency injection to avoid circular dependencies. Ensure each module has a clear API and properly encapsulates its internal state. Focus on the critical path functionality first.",
          "status": "done",
          "dependencies": [
            2
          ],
          "acceptanceCriteria": "- All core functionality migrated to appropriate modules"
        },
        {
          "id": 4,
          "title": "Implement Error Handling and Complete Module Migration",
          "description": "Establish a consistent error handling pattern across all modules. Complete the migration of remaining functionality from dev.js to the appropriate modules. Ensure all edge cases, error scenarios, and helper functions are properly moved and integrated. Update all import/export statements throughout the codebase to reference the new module structure.",
          "status": "done",
          "dependencies": [
            3
          ],
          "acceptanceCriteria": "- Consistent error handling pattern implemented across all modules"
        },
        {
          "id": 5,
          "title": "Test, Document, and Finalize Modular Structure",
          "description": "Perform comprehensive testing of the refactored codebase to ensure all functionality works as expected. Add detailed JSDoc comments to all modules, functions, and significant code blocks. Create or update developer documentation explaining the new modular structure, module responsibilities, and how they interact. Perform a final code review to ensure code quality, consistency, and adherence to best practices.",
          "status": "done",
          "dependencies": [
            "21.4"
          ],
          "acceptanceCriteria": "- All existing functionality works exactly as before"
        }
      ]
    },
    {
      "id": 22,
      "title": "Create Comprehensive Test Suite for Task Master CLI",
      "description": "Develop a complete testing infrastructure for the Task Master CLI that includes unit, integration, and end-to-end tests to verify all core functionality and error handling.",
      "status": "done",
      "dependencies": [
        21
      ],
      "priority": "high",
      "details": "Implement a comprehensive test suite using Jest as the testing framework. The test suite should be organized into three main categories:\n\n1. Unit Tests:\n   - Create tests for all utility functions and core logic components\n   - Test task creation, parsing, and manipulation functions\n   - Test data storage and retrieval functions\n   - Test formatting and display functions\n\n2. Integration Tests:\n   - Test all CLI commands (create, expand, update, list, etc.)\n   - Verify command options and parameters work correctly\n   - Test interactions between different components\n   - Test configuration loading and application settings\n\n3. End-to-End Tests:\n   - Test complete workflows (e.g., creating a task, expanding it, updating status)\n   - Test error scenarios and recovery\n   - Test edge cases like handling large numbers of tasks\n\nImplement proper mocking for:\n- Claude API interactions (using Jest mock functions)\n- File system operations (using mock-fs or similar)\n- User input/output (using mock stdin/stdout)\n\nEnsure tests cover both successful operations and error handling paths. Set up continuous integration to run tests automatically. Create fixtures for common test data and scenarios. Include test coverage reporting to identify untested code paths.",
      "testStrategy": "Verification will involve:\n\n1. Code Review:\n   - Verify test organization follows the unit/integration/end-to-end structure\n   - Check that all major functions have corresponding tests\n   - Verify mocks are properly implemented for external dependencies\n\n2. Test Coverage Analysis:\n   - Run test coverage tools to ensure at least 80% code coverage\n   - Verify critical paths have 100% coverage\n   - Identify any untested code paths\n\n3. Test Quality Verification:\n   - Manually review test cases to ensure they test meaningful behavior\n   - Verify both positive and negative test cases exist\n   - Check that tests are deterministic and don't have false positives/negatives\n\n4. CI Integration:\n   - Verify tests run successfully in the CI environment\n   - Ensure tests run in a reasonable amount of time\n   - Check that test failures provide clear, actionable information\n\nThe task will be considered complete when all tests pass consistently, coverage meets targets, and the test suite can detect intentionally introduced bugs.",
      "subtasks": [
        {
          "id": 1,
          "title": "Set Up Jest Testing Environment",
          "description": "Configure Jest for the project, including setting up the jest.config.js file, adding necessary dependencies, and creating the initial test directory structure. Implement proper mocking for Claude API interactions, file system operations, and user input/output. Set up test coverage reporting and configure it to run in the CI pipeline.",
          "status": "done",
          "dependencies": [],
          "acceptanceCriteria": "- jest.config.js is properly configured for the project"
        },
        {
          "id": 2,
          "title": "Implement Unit Tests for Core Components",
          "description": "Create a comprehensive set of unit tests for all utility functions, core logic components, and individual modules of the Task Master CLI. This includes tests for task creation, parsing, manipulation, data storage, retrieval, and formatting functions. Ensure all edge cases and error scenarios are covered.",
          "status": "done",
          "dependencies": [
            1
          ],
          "acceptanceCriteria": "- Unit tests are implemented for all utility functions in the project"
        },
        {
          "id": 3,
          "title": "Develop Integration and End-to-End Tests",
          "description": "Create integration tests that verify the correct interaction between different components of the CLI, including command execution, option parsing, and data flow. Implement end-to-end tests that simulate complete user workflows, such as creating a task, expanding it, and updating its status. Include tests for error scenarios, recovery processes, and handling large numbers of tasks.",
          "status": "deferred",
          "dependencies": [
            1,
            2
          ],
          "acceptanceCriteria": "- Integration tests cover all CLI commands (create, expand, update, list, etc.)"
        }
      ]
    },
    {
      "id": 23,
      "title": "Complete MCP Server Implementation for Task Master using FastMCP",
      "description": "Finalize the MCP server functionality for Task Master by leveraging FastMCP's capabilities, transitioning from CLI-based execution to direct function imports, and optimizing performance, authentication, and context management. Ensure the server integrates seamlessly with Cursor via `mcp.json` and supports proper tool registration, efficient context handling, and transport type handling (focusing on stdio). Additionally, ensure the server can be instantiated properly when installed via `npx` or `npm i -g`. Evaluate and address gaps in the current implementation, including function imports, context management, caching, tool registration, and adherence to FastMCP best practices.",
      "status": "in-progress",
      "dependencies": [
        22
      ],
      "priority": "medium",
      "details": "This task involves completing the Model Context Protocol (MCP) server implementation for Task Master using FastMCP. Key updates include:\n\n1. Transition from CLI-based execution (currently using `child_process.spawnSync`) to direct Task Master function imports for improved performance and reliability.\n2. Implement caching mechanisms for frequently accessed contexts to enhance performance, leveraging FastMCP's efficient transport mechanisms (e.g., stdio).\n3. Refactor context management to align with best practices for handling large context windows, metadata, and tagging.\n4. Refactor tool registration in `tools/index.js` to include clear descriptions and parameter definitions, leveraging FastMCP's decorator-based patterns for better integration.\n5. Enhance transport type handling to ensure proper stdio communication and compatibility with FastMCP.\n6. Ensure the MCP server can be instantiated and run correctly when installed globally via `npx` or `npm i -g`.\n7. Integrate the ModelContextProtocol SDK directly to streamline resource and tool registration, ensuring compatibility with FastMCP's transport mechanisms.\n8. Identify and address missing components or functionalities to meet FastMCP best practices, such as robust error handling, monitoring endpoints, and concurrency support.\n9. Update documentation to include examples of using the MCP server with FastMCP, detailed setup instructions, and client integration guides.\n10. Organize direct function implementations in a modular structure within the mcp-server/src/core/direct-functions/ directory for improved maintainability and organization.\n11. Follow consistent naming conventions: file names use kebab-case (like-this.js), direct functions use camelCase with Direct suffix (functionNameDirect), tool registration functions use camelCase with Tool suffix (registerToolNameTool), and MCP tool names exposed to clients use snake_case (tool_name).\n\nThe implementation must ensure compatibility with existing MCP clients and follow RESTful API design principles, while supporting concurrent requests and maintaining robust error handling.",
      "testStrategy": "Testing for the MCP server implementation will follow a comprehensive approach based on our established testing guidelines:\n\n## Test Organization\n\n1. **Unit Tests** (`tests/unit/mcp-server/`):\n   - Test individual MCP server components in isolation\n   - Mock all external dependencies including FastMCP SDK\n   - Test each tool implementation separately\n   - Test each direct function implementation in the direct-functions directory\n   - Verify direct function imports work correctly\n   - Test context management and caching mechanisms\n   - Example files: `context-manager.test.js`, `tool-registration.test.js`, `direct-functions/list-tasks.test.js`\n\n2. **Integration Tests** (`tests/integration/mcp-server/`):\n   - Test interactions between MCP server components\n   - Verify proper tool registration with FastMCP\n   - Test context flow between components\n   - Validate error handling across module boundaries\n   - Test the integration between direct functions and their corresponding MCP tools\n   - Example files: `server-tool-integration.test.js`, `context-flow.test.js`\n\n3. **End-to-End Tests** (`tests/e2e/mcp-server/`):\n   - Test complete MCP server workflows\n   - Verify server instantiation via different methods (direct, npx, global install)\n   - Test actual stdio communication with mock clients\n   - Example files: `server-startup.e2e.test.js`, `client-communication.e2e.test.js`\n\n4. **Test Fixtures** (`tests/fixtures/mcp-server/`):\n   - Sample context data\n   - Mock tool definitions\n   - Sample MCP requests and responses\n\n## Testing Approach\n\n### Module Mocking Strategy\n```javascript\n// Mock the FastMCP SDK\njest.mock('@model-context-protocol/sdk', () => ({\n  MCPServer: jest.fn().mockImplementation(() => ({\n    registerTool: jest.fn(),\n    registerResource: jest.fn(),\n    start: jest.fn().mockResolvedValue(undefined),\n    stop: jest.fn().mockResolvedValue(undefined)\n  })),\n  MCPError: jest.fn().mockImplementation(function(message, code) {\n    this.message = message;\n    this.code = code;\n  })\n}));\n\n// Import modules after mocks\nimport { MCPServer, MCPError } from '@model-context-protocol/sdk';\nimport { initMCPServer } from '../../scripts/mcp-server.js';\n```\n\n### Direct Function Testing\n- Test each direct function in isolation\n- Verify proper error handling and return formats\n- Test with various input parameters and edge cases\n- Verify integration with the task-master-core.js export hub\n\n### Context Management Testing\n- Test context creation, retrieval, and manipulation\n- Verify caching mechanisms work correctly\n- Test context windowing and metadata handling\n- Validate context persistence across server restarts\n\n### Direct Function Import Testing\n- Verify Task Master functions are imported correctly\n- Test performance improvements compared to CLI execution\n- Validate error handling with direct imports\n\n### Tool Registration Testing\n- Verify tools are registered with proper descriptions and parameters\n- Test decorator-based registration patterns\n- Validate tool execution with different input types\n\n### Error Handling Testing\n- Test all error paths with appropriate MCPError types\n- Verify error propagation to clients\n- Test recovery from various error conditions\n\n### Performance Testing\n- Benchmark response times with and without caching\n- Test memory usage under load\n- Verify concurrent request handling\n\n## Test Quality Guidelines\n\n- Follow TDD approach when possible\n- Maintain test independence and isolation\n- Use descriptive test names explaining expected behavior\n- Aim for 80%+ code coverage, with critical paths at 100%\n- Follow the mock-first-then-import pattern for all Jest mocks\n- Avoid testing implementation details that might change\n- Ensure tests don't depend on execution order\n\n## Specific Test Cases\n\n1. **Server Initialization**\n   - Test server creation with various configuration options\n   - Verify proper tool and resource registration\n   - Test server startup and shutdown procedures\n\n2. **Context Operations**\n   - Test context creation, retrieval, update, and deletion\n   - Verify context windowing and truncation\n   - Test context metadata and tagging\n\n3. **Tool Execution**\n   - Test each tool with various input parameters\n   - Verify proper error handling for invalid inputs\n   - Test tool execution performance\n\n4. **MCP.json Integration**\n   - Test creation and updating of .cursor/mcp.json\n   - Verify proper server registration in mcp.json\n   - Test handling of existing mcp.json files\n\n5. **Transport Handling**\n   - Test stdio communication\n   - Verify proper message formatting\n   - Test error handling in transport layer\n\n6. **Direct Function Structure**\n   - Test the modular organization of direct functions\n   - Verify proper import/export through task-master-core.js\n   - Test utility functions in the utils directory\n\nAll tests will be automated and integrated into the CI/CD pipeline to ensure consistent quality.",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Core MCP Server Module and Basic Structure",
          "description": "Create the foundation for the MCP server implementation by setting up the core module structure, configuration, and server initialization.",
          "dependencies": [],
          "details": "Implementation steps:\n1. Create a new module `mcp-server.js` with the basic server structure\n2. Implement configuration options to enable/disable the MCP server\n3. Set up Express.js routes for the required MCP endpoints (/context, /models, /execute)\n4. Create middleware for request validation and response formatting\n5. Implement basic error handling according to MCP specifications\n6. Add logging infrastructure for MCP operations\n7. Create initialization and shutdown procedures for the MCP server\n8. Set up integration with the main Task Master application\n\nTesting approach:\n- Unit tests for configuration loading and validation\n- Test server initialization and shutdown procedures\n- Verify that routes are properly registered\n- Test basic error handling with invalid requests",
          "status": "done",
          "parentTaskId": 23
        },
        {
          "id": 2,
          "title": "Implement Context Management System",
          "description": "Develop a robust context management system that can efficiently store, retrieve, and manipulate context data according to the MCP specification.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Design and implement data structures for context storage\n2. Create methods for context creation, retrieval, updating, and deletion\n3. Implement context windowing and truncation algorithms for handling size limits\n4. Add support for context metadata and tagging\n5. Create utilities for context serialization and deserialization\n6. Implement efficient indexing for quick context lookups\n7. Add support for context versioning and history\n8. Develop mechanisms for context persistence (in-memory, disk-based, or database)\n\nTesting approach:\n- Unit tests for all context operations (CRUD)\n- Performance tests for context retrieval with various sizes\n- Test context windowing and truncation with edge cases\n- Verify metadata handling and tagging functionality\n- Test persistence mechanisms with simulated failures",
          "status": "done",
          "parentTaskId": 23
        },
        {
          "id": 3,
          "title": "Implement MCP Endpoints and API Handlers",
          "description": "Develop the complete API handlers for all required MCP endpoints, ensuring they follow the protocol specification and integrate with the context management system.",
          "dependencies": [
            1,
            2
          ],
          "details": "Implementation steps:\n1. Implement the `/context` endpoint for:\n   - GET: retrieving existing context\n   - POST: creating new context\n   - PUT: updating existing context\n   - DELETE: removing context\n2. Implement the `/models` endpoint to list available models\n3. Develop the `/execute` endpoint for performing operations with context\n4. Create request validators for each endpoint\n5. Implement response formatters according to MCP specifications\n6. Add detailed error handling for each endpoint\n7. Set up proper HTTP status codes for different scenarios\n8. Implement pagination for endpoints that return lists\n\nTesting approach:\n- Unit tests for each endpoint handler\n- Integration tests with mock context data\n- Test various request formats and edge cases\n- Verify response formats match MCP specifications\n- Test error handling with invalid inputs\n- Benchmark endpoint performance",
          "status": "done",
          "parentTaskId": 23
        },
        {
          "id": 6,
          "title": "Refactor MCP Server to Leverage ModelContextProtocol SDK",
          "description": "Integrate the ModelContextProtocol SDK directly into the MCP server implementation to streamline tool registration and resource handling.",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Implementation steps:\n1. Replace manual tool registration with ModelContextProtocol SDK methods.\n2. Use SDK utilities to simplify resource and template management.\n3. Ensure compatibility with FastMCP's transport mechanisms.\n4. Update server initialization to include SDK-based configurations.\n\nTesting approach:\n- Verify SDK integration with all MCP endpoints.\n- Test resource and template registration using SDK methods.\n- Validate compatibility with existing MCP clients.\n- Benchmark performance improvements from SDK integration.\n\n<info added on 2025-03-31T18:49:14.439Z>\nThe subtask is being cancelled because FastMCP already serves as a higher-level abstraction over the Model Context Protocol SDK. Direct integration with the MCP SDK would be redundant and potentially counterproductive since:\n\n1. FastMCP already encapsulates the necessary SDK functionality for tool registration and resource handling\n2. The existing FastMCP abstractions provide a more streamlined developer experience\n3. Adding another layer of SDK integration would increase complexity without clear benefits\n4. The transport mechanisms in FastMCP are already optimized for the current architecture\n\nInstead, we should focus on extending and enhancing the existing FastMCP abstractions where needed, rather than attempting to bypass them with direct SDK integration.\n</info added on 2025-03-31T18:49:14.439Z>",
          "status": "cancelled",
          "parentTaskId": 23
        },
        {
          "id": 8,
          "title": "Implement Direct Function Imports and Replace CLI-based Execution",
          "description": "Refactor the MCP server implementation to use direct Task Master function imports instead of the current CLI-based execution using child_process.spawnSync. This will improve performance, reliability, and enable better error handling.",
          "dependencies": [
            "23.13"
          ],
          "details": "\n\n<info added on 2025-03-30T00:14:10.040Z>\n```\n# Refactoring Strategy for Direct Function Imports\n\n## Core Approach\n1. Create a clear separation between data retrieval/processing and presentation logic\n2. Modify function signatures to accept `outputFormat` parameter ('cli'|'json', default: 'cli')\n3. Implement early returns for JSON format to bypass CLI-specific code\n\n## Implementation Details for `listTasks`\n```javascript\nfunction listTasks(tasksPath, statusFilter, withSubtasks = false, outputFormat = 'cli') {\n  try {\n    // Existing data retrieval logic\n    const filteredTasks = /* ... */;\n    \n    // Early return for JSON format\n    if (outputFormat === 'json') return filteredTasks;\n    \n    // Existing CLI output logic\n  } catch (error) {\n    if (outputFormat === 'json') {\n      throw {\n        code: 'TASK_LIST_ERROR',\n        message: error.message,\n        details: error.stack\n      };\n    } else {\n      console.error(error);\n      process.exit(1);\n    }\n  }\n}\n```\n\n## Testing Strategy\n- Create integration tests in `tests/integration/mcp-server/`\n- Use FastMCP InMemoryTransport for direct client-server testing\n- Test both JSON and CLI output formats\n- Verify structure consistency with schema validation\n\n## Additional Considerations\n- Update JSDoc comments to document new parameters and return types\n- Ensure backward compatibility with default CLI behavior\n- Add JSON schema validation for consistent output structure\n- Apply similar pattern to other core functions (expandTask, updateTaskById, etc.)\n\n## Error Handling Improvements\n- Standardize error format for JSON returns:\n```javascript\n{\n  code: 'ERROR_CODE',\n  message: 'Human-readable message',\n  details: {}, // Additional context when available\n  stack: process.env.NODE_ENV === 'development' ? error.stack : undefined\n}\n```\n- Enrich JSON errors with error codes and debug info\n- Ensure validation failures return proper objects in JSON mode\n```\n</info added on 2025-03-30T00:14:10.040Z>",
          "status": "done",
          "parentTaskId": 23
        },
        {
          "id": 9,
          "title": "Implement Context Management and Caching Mechanisms",
          "description": "Enhance the MCP server with proper context management and caching to improve performance and user experience, especially for frequently accessed data and contexts.",
          "dependencies": [
            1
          ],
          "details": "1. Implement a context manager class that leverages FastMCP's Context object\n2. Add caching for frequently accessed task data with configurable TTL settings\n3. Implement context tagging for better organization of context data\n4. Add methods to efficiently handle large context windows\n5. Create helper functions for storing and retrieving context data\n6. Implement cache invalidation strategies for task updates\n7. Add cache statistics for monitoring performance\n8. Create unit tests for context management and caching functionality",
          "status": "done",
          "parentTaskId": 23
        },
        {
          "id": 10,
          "title": "Enhance Tool Registration and Resource Management",
          "description": "Refactor tool registration to follow FastMCP best practices, using decorators and improving the overall structure. Implement proper resource management for task templates and other shared resources.",
          "dependencies": [
            1,
            "23.8"
          ],
          "details": "1. Update registerTaskMasterTools function to use FastMCP's decorator pattern\n2. Implement @mcp.tool() decorators for all existing tools\n3. Add proper type annotations and documentation for all tools\n4. Create resource handlers for task templates using @mcp.resource()\n5. Implement resource templates for common task patterns\n6. Update the server initialization to properly register all tools and resources\n7. Add validation for tool inputs using FastMCP's built-in validation\n8. Create comprehensive tests for tool registration and resource access\n\n<info added on 2025-03-31T18:35:21.513Z>\nHere is additional information to enhance the subtask regarding resources and resource templates in FastMCP:\n\nResources in FastMCP are used to expose static or dynamic data to LLM clients. For the Task Master MCP server, we should implement resources to provide:\n\n1. Task templates: Predefined task structures that can be used as starting points\n2. Workflow definitions: Reusable workflow patterns for common task sequences\n3. User preferences: Stored user settings for task management\n4. Project metadata: Information about active projects and their attributes\n\nResource implementation should follow this structure:\n\n```python\n@mcp.resource(\"tasks://templates/{template_id}\")\ndef get_task_template(template_id: str) -> dict:\n    # Fetch and return the specified task template\n    ...\n\n@mcp.resource(\"workflows://definitions/{workflow_id}\")\ndef get_workflow_definition(workflow_id: str) -> dict:\n    # Fetch and return the specified workflow definition\n    ...\n\n@mcp.resource(\"users://{user_id}/preferences\")\ndef get_user_preferences(user_id: str) -> dict:\n    # Fetch and return user preferences\n    ...\n\n@mcp.resource(\"projects://metadata\")\ndef get_project_metadata() -> List[dict]:\n    # Fetch and return metadata for all active projects\n    ...\n```\n\nResource templates in FastMCP allow for dynamic generation of resources based on patterns. For Task Master, we can implement:\n\n1. Dynamic task creation templates\n2. Customizable workflow templates\n3. User-specific resource views\n\nExample implementation:\n\n```python\n@mcp.resource(\"tasks://create/{task_type}\")\ndef get_task_creation_template(task_type: str) -> dict:\n    # Generate and return a task creation template based on task_type\n    ...\n\n@mcp.resource(\"workflows://custom/{user_id}/{workflow_name}\")\ndef get_custom_workflow_template(user_id: str, workflow_name: str) -> dict:\n    # Generate and return a custom workflow template for the user\n    ...\n\n@mcp.resource(\"users://{user_id}/dashboard\")\ndef get_user_dashboard(user_id: str) -> dict:\n    # Generate and return a personalized dashboard view for the user\n    ...\n```\n\nBest practices for integrating resources with Task Master functionality:\n\n1. Use resources to provide context and data for tools\n2. Implement caching for frequently accessed resources\n3. Ensure proper error handling and not-found cases for all resources\n4. Use resource templates to generate dynamic, personalized views of data\n5. Implement access control to ensure users only access authorized resources\n\nBy properly implementing these resources and resource templates, we can provide rich, contextual data to LLM clients, enhancing the Task Master's capabilities and user experience.\n</info added on 2025-03-31T18:35:21.513Z>",
          "status": "deferred",
          "parentTaskId": 23
        },
        {
          "id": 11,
          "title": "Implement Comprehensive Error Handling",
          "description": "Implement robust error handling using FastMCP's MCPError, including custom error types for different categories and standardized error responses.",
          "details": "1. Create custom error types extending MCPError for different categories (validation, auth, etc.)\\n2. Implement standardized error responses following MCP protocol\\n3. Add error handling middleware for all MCP endpoints\\n4. Ensure proper error propagation from tools to client\\n5. Add debug mode with detailed error information\\n6. Document error types and handling patterns",
          "status": "deferred",
          "dependencies": [
            "23.1",
            "23.3"
          ],
          "parentTaskId": 23
        },
        {
          "id": 12,
          "title": "Implement Structured Logging System",
          "description": "Implement a comprehensive logging system for the MCP server with different log levels, structured logging format, and request/response tracking.",
          "details": "1. Design structured log format for consistent parsing\\n2. Implement different log levels (debug, info, warn, error)\\n3. Add request/response logging middleware\\n4. Implement correlation IDs for request tracking\\n5. Add performance metrics logging\\n6. Configure log output destinations (console, file)\\n7. Document logging patterns and usage",
          "status": "done",
          "dependencies": [
            "23.1",
            "23.3"
          ],
          "parentTaskId": 23
        },
        {
          "id": 13,
          "title": "Create Testing Framework and Test Suite",
          "description": "Implement a comprehensive testing framework for the MCP server, including unit tests, integration tests, and end-to-end tests.",
          "details": "1. Set up Jest testing framework with proper configuration\\n2. Create MCPTestClient for testing FastMCP server interaction\\n3. Implement unit tests for individual tool functions\\n4. Create integration tests for end-to-end request/response cycles\\n5. Set up test fixtures and mock data\\n6. Implement test coverage reporting\\n7. Document testing guidelines and examples",
          "status": "deferred",
          "dependencies": [
            "23.1",
            "23.3"
          ],
          "parentTaskId": 23
        },
        {
          "id": 14,
          "title": "Add MCP.json to the Init Workflow",
          "description": "Implement functionality to create or update .cursor/mcp.json during project initialization, handling cases where: 1) If there's no mcp.json, create it with the appropriate configuration; 2) If there is an mcp.json, intelligently append to it without syntax errors like trailing commas",
          "details": "1. Create functionality to detect if .cursor/mcp.json exists in the project\\n2. Implement logic to create a new mcp.json file with proper structure if it doesn't exist\\n3. Add functionality to read and parse existing mcp.json if it exists\\n4. Create method to add a new taskmaster-ai server entry to the mcpServers object\\n5. Implement intelligent JSON merging that avoids trailing commas and syntax errors\\n6. Ensure proper formatting and indentation in the generated/updated JSON\\n7. Add validation to verify the updated configuration is valid JSON\\n8. Include this functionality in the init workflow\\n9. Add error handling for file system operations and JSON parsing\\n10. Document the mcp.json structure and integration process",
          "status": "done",
          "dependencies": [
            "23.1",
            "23.3"
          ],
          "parentTaskId": 23
        },
        {
          "id": 15,
          "title": "Implement SSE Support for Real-time Updates",
          "description": "Add Server-Sent Events (SSE) capabilities to the MCP server to enable real-time updates and streaming of task execution progress, logs, and status changes to clients",
          "details": "1. Research and implement SSE protocol for the MCP server\\n2. Create dedicated SSE endpoints for event streaming\\n3. Implement event emitter pattern for internal event management\\n4. Add support for different event types (task status, logs, errors)\\n5. Implement client connection management with proper keep-alive handling\\n6. Add filtering capabilities to allow subscribing to specific event types\\n7. Create in-memory event buffer for clients reconnecting\\n8. Document SSE endpoint usage and client implementation examples\\n9. Add robust error handling for dropped connections\\n10. Implement rate limiting and backpressure mechanisms\\n11. Add authentication for SSE connections",
          "status": "deferred",
          "dependencies": [
            "23.1",
            "23.3",
            "23.11"
          ],
          "parentTaskId": 23
        },
        {
          "id": 16,
          "title": "Implement parse-prd MCP command",
          "description": "Create direct function wrapper and MCP tool for parsing PRD documents to generate tasks.",
          "details": "Following MCP implementation standards:\\n\\n1. Create parsePRDDirect function in task-master-core.js:\\n   - Import parsePRD from task-manager.js\\n   - Handle file paths using findTasksJsonPath utility\\n   - Process arguments: input file, output path, numTasks\\n   - Validate inputs and handle errors with try/catch\\n   - Return standardized { success, data/error } object\\n   - Add to directFunctions map\\n\\n2. Create parse-prd.js MCP tool in mcp-server/src/tools/:\\n   - Import z from zod for parameter schema\\n   - Import executeMCPToolAction from ./utils.js\\n   - Import parsePRDDirect from task-master-core.js\\n   - Define parameters matching CLI options using zod schema\\n   - Implement registerParsePRDTool(server) with server.addTool\\n   - Use executeMCPToolAction in execute method\\n\\n3. Register in tools/index.js\\n\\n4. Add to .cursor/mcp.json with appropriate schema\\n\\n5. Write tests following testing guidelines:\\n   - Unit test for parsePRDDirect\\n   - Integration test for MCP tool",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 23
        },
        {
          "id": 17,
          "title": "Implement update MCP command",
          "description": "Create direct function wrapper and MCP tool for updating multiple tasks based on prompt.",
          "details": "Following MCP implementation standards:\\n\\n1. Create updateTasksDirect function in task-master-core.js:\\n   - Import updateTasks from task-manager.js\\n   - Handle file paths using findTasksJsonPath utility\\n   - Process arguments: fromId, prompt, useResearch\\n   - Validate inputs and handle errors with try/catch\\n   - Return standardized { success, data/error } object\\n   - Add to directFunctions map\\n\\n2. Create update.js MCP tool in mcp-server/src/tools/:\\n   - Import z from zod for parameter schema\\n   - Import executeMCPToolAction from ./utils.js\\n   - Import updateTasksDirect from task-master-core.js\\n   - Define parameters matching CLI options using zod schema\\n   - Implement registerUpdateTool(server) with server.addTool\\n   - Use executeMCPToolAction in execute method\\n\\n3. Register in tools/index.js\\n\\n4. Add to .cursor/mcp.json with appropriate schema\\n\\n5. Write tests following testing guidelines:\\n   - Unit test for updateTasksDirect\\n   - Integration test for MCP tool",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 23
        },
        {
          "id": 18,
          "title": "Implement update-task MCP command",
          "description": "Create direct function wrapper and MCP tool for updating a single task by ID with new information.",
          "details": "Following MCP implementation standards:\n\n1. Create updateTaskByIdDirect.js in mcp-server/src/core/direct-functions/:\n   - Import updateTaskById from task-manager.js\n   - Handle file paths using findTasksJsonPath utility\n   - Process arguments: taskId, prompt, useResearch\n   - Validate inputs and handle errors with try/catch\n   - Return standardized { success, data/error } object\n\n2. Export from task-master-core.js:\n   - Import the function from its file\n   - Add to directFunctions map\n\n3. Create update-task.js MCP tool in mcp-server/src/tools/:\n   - Import z from zod for parameter schema\n   - Import executeMCPToolAction from ./utils.js\n   - Import updateTaskByIdDirect from task-master-core.js\n   - Define parameters matching CLI options using zod schema\n   - Implement registerUpdateTaskTool(server) with server.addTool\n   - Use executeMCPToolAction in execute method\n\n4. Register in tools/index.js\n\n5. Add to .cursor/mcp.json with appropriate schema\n\n6. Write tests following testing guidelines:\n   - Unit test for updateTaskByIdDirect.js\n   - Integration test for MCP tool",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 23
        },
        {
          "id": 19,
          "title": "Implement update-subtask MCP command",
          "description": "Create direct function wrapper and MCP tool for appending information to a specific subtask.",
          "details": "Following MCP implementation standards:\n\n1. Create updateSubtaskByIdDirect.js in mcp-server/src/core/direct-functions/:\n   - Import updateSubtaskById from task-manager.js\n   - Handle file paths using findTasksJsonPath utility\n   - Process arguments: subtaskId, prompt, useResearch\n   - Validate inputs and handle errors with try/catch\n   - Return standardized { success, data/error } object\n\n2. Export from task-master-core.js:\n   - Import the function from its file\n   - Add to directFunctions map\n\n3. Create update-subtask.js MCP tool in mcp-server/src/tools/:\n   - Import z from zod for parameter schema\n   - Import executeMCPToolAction from ./utils.js\n   - Import updateSubtaskByIdDirect from task-master-core.js\n   - Define parameters matching CLI options using zod schema\n   - Implement registerUpdateSubtaskTool(server) with server.addTool\n   - Use executeMCPToolAction in execute method\n\n4. Register in tools/index.js\n\n5. Add to .cursor/mcp.json with appropriate schema\n\n6. Write tests following testing guidelines:\n   - Unit test for updateSubtaskByIdDirect.js\n   - Integration test for MCP tool",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 23
        },
        {
          "id": 20,
          "title": "Implement generate MCP command",
          "description": "Create direct function wrapper and MCP tool for generating task files from tasks.json.",
          "details": "Following MCP implementation standards:\n\n1. Create generateTaskFilesDirect.js in mcp-server/src/core/direct-functions/:\n   - Import generateTaskFiles from task-manager.js\n   - Handle file paths using findTasksJsonPath utility\n   - Process arguments: tasksPath, outputDir\n   - Validate inputs and handle errors with try/catch\n   - Return standardized { success, data/error } object\n\n2. Export from task-master-core.js:\n   - Import the function from its file\n   - Add to directFunctions map\n\n3. Create generate.js MCP tool in mcp-server/src/tools/:\n   - Import z from zod for parameter schema\n   - Import executeMCPToolAction from ./utils.js\n   - Import generateTaskFilesDirect from task-master-core.js\n   - Define parameters matching CLI options using zod schema\n   - Implement registerGenerateTool(server) with server.addTool\n   - Use executeMCPToolAction in execute method\n\n4. Register in tools/index.js\n\n5. Add to .cursor/mcp.json with appropriate schema\n\n6. Write tests following testing guidelines:\n   - Unit test for generateTaskFilesDirect.js\n   - Integration test for MCP tool",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 23
        },
        {
          "id": 21,
          "title": "Implement set-status MCP command",
          "description": "Create direct function wrapper and MCP tool for setting task status.",
          "details": "Following MCP implementation standards:\n\n1. Create setTaskStatusDirect.js in mcp-server/src/core/direct-functions/:\n   - Import setTaskStatus from task-manager.js\n   - Handle file paths using findTasksJsonPath utility\n   - Process arguments: taskId, status\n   - Validate inputs and handle errors with try/catch\n   - Return standardized { success, data/error } object\n\n2. Export from task-master-core.js:\n   - Import the function from its file\n   - Add to directFunctions map\n\n3. Create set-status.js MCP tool in mcp-server/src/tools/:\n   - Import z from zod for parameter schema\n   - Import executeMCPToolAction from ./utils.js\n   - Import setTaskStatusDirect from task-master-core.js\n   - Define parameters matching CLI options using zod schema\n   - Implement registerSetStatusTool(server) with server.addTool\n   - Use executeMCPToolAction in execute method\n\n4. Register in tools/index.js\n\n5. Add to .cursor/mcp.json with appropriate schema\n\n6. Write tests following testing guidelines:\n   - Unit test for setTaskStatusDirect.js\n   - Integration test for MCP tool",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 23
        },
        {
          "id": 22,
          "title": "Implement show-task MCP command",
          "description": "Create direct function wrapper and MCP tool for showing task details.",
          "details": "Following MCP implementation standards:\n\n1. Create showTaskDirect.js in mcp-server/src/core/direct-functions/:\n   - Import showTask from task-manager.js\n   - Handle file paths using findTasksJsonPath utility\n   - Process arguments: taskId\n   - Validate inputs and handle errors with try/catch\n   - Return standardized { success, data/error } object\n\n2. Export from task-master-core.js:\n   - Import the function from its file\n   - Add to directFunctions map\n\n3. Create show-task.js MCP tool in mcp-server/src/tools/:\n   - Import z from zod for parameter schema\n   - Import executeMCPToolAction from ./utils.js\n   - Import showTaskDirect from task-master-core.js\n   - Define parameters matching CLI options using zod schema\n   - Implement registerShowTaskTool(server) with server.addTool\n   - Use executeMCPToolAction in execute method\n\n4. Register in tools/index.js with tool name 'show_task'\n\n5. Add to .cursor/mcp.json with appropriate schema\n\n6. Write tests following testing guidelines:\n   - Unit test for showTaskDirect.js\n   - Integration test for MCP tool",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 23
        },
        {
          "id": 23,
          "title": "Implement next-task MCP command",
          "description": "Create direct function wrapper and MCP tool for finding the next task to work on.",
          "details": "Following MCP implementation standards:\n\n1. Create nextTaskDirect.js in mcp-server/src/core/direct-functions/:\n   - Import nextTask from task-manager.js\n   - Handle file paths using findTasksJsonPath utility\n   - Process arguments (no specific args needed except projectRoot/file)\n   - Handle errors with try/catch\n   - Return standardized { success, data/error } object\n\n2. Export from task-master-core.js:\n   - Import the function from its file\n   - Add to directFunctions map\n\n3. Create next-task.js MCP tool in mcp-server/src/tools/:\n   - Import z from zod for parameter schema\n   - Import executeMCPToolAction from ./utils.js\n   - Import nextTaskDirect from task-master-core.js\n   - Define parameters matching CLI options using zod schema\n   - Implement registerNextTaskTool(server) with server.addTool\n   - Use executeMCPToolAction in execute method\n\n4. Register in tools/index.js with tool name 'next_task'\n\n5. Add to .cursor/mcp.json with appropriate schema\n\n6. Write tests following testing guidelines:\n   - Unit test for nextTaskDirect.js\n   - Integration test for MCP tool",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 23
        },
        {
          "id": 24,
          "title": "Implement expand-task MCP command",
          "description": "Create direct function wrapper and MCP tool for expanding a task into subtasks.",
          "details": "Following MCP implementation standards:\n\n1. Create expandTaskDirect.js in mcp-server/src/core/direct-functions/:\n   - Import expandTask from task-manager.js\n   - Handle file paths using findTasksJsonPath utility\n   - Process arguments: taskId, prompt, num, force, research\n   - Validate inputs and handle errors with try/catch\n   - Return standardized { success, data/error } object\n\n2. Export from task-master-core.js:\n   - Import the function from its file\n   - Add to directFunctions map\n\n3. Create expand-task.js MCP tool in mcp-server/src/tools/:\n   - Import z from zod for parameter schema\n   - Import executeMCPToolAction from ./utils.js\n   - Import expandTaskDirect from task-master-core.js\n   - Define parameters matching CLI options using zod schema\n   - Implement registerExpandTaskTool(server) with server.addTool\n   - Use executeMCPToolAction in execute method\n\n4. Register in tools/index.js with tool name 'expand_task'\n\n5. Add to .cursor/mcp.json with appropriate schema\n\n6. Write tests following testing guidelines:\n   - Unit test for expandTaskDirect.js\n   - Integration test for MCP tool",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 23
        },
        {
          "id": 25,
          "title": "Implement add-task MCP command",
          "description": "Create direct function wrapper and MCP tool for adding new tasks.",
          "details": "Following MCP implementation standards:\n\n1. Create addTaskDirect.js in mcp-server/src/core/direct-functions/:\n   - Import addTask from task-manager.js\n   - Handle file paths using findTasksJsonPath utility\n   - Process arguments: prompt, priority, dependencies\n   - Validate inputs and handle errors with try/catch\n   - Return standardized { success, data/error } object\n\n2. Export from task-master-core.js:\n   - Import the function from its file\n   - Add to directFunctions map\n\n3. Create add-task.js MCP tool in mcp-server/src/tools/:\n   - Import z from zod for parameter schema\n   - Import executeMCPToolAction from ./utils.js\n   - Import addTaskDirect from task-master-core.js\n   - Define parameters matching CLI options using zod schema\n   - Implement registerAddTaskTool(server) with server.addTool\n   - Use executeMCPToolAction in execute method\n\n4. Register in tools/index.js with tool name 'add_task'\n\n5. Add to .cursor/mcp.json with appropriate schema\n\n6. Write tests following testing guidelines:\n   - Unit test for addTaskDirect.js\n   - Integration test for MCP tool",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 23
        },
        {
          "id": 26,
          "title": "Implement add-subtask MCP command",
          "description": "Create direct function wrapper and MCP tool for adding subtasks to existing tasks.",
          "details": "Following MCP implementation standards:\n\n1. Create addSubtaskDirect.js in mcp-server/src/core/direct-functions/:\n   - Import addSubtask from task-manager.js\n   - Handle file paths using findTasksJsonPath utility\n   - Process arguments: parentTaskId, title, description, details\n   - Validate inputs and handle errors with try/catch\n   - Return standardized { success, data/error } object\n\n2. Export from task-master-core.js:\n   - Import the function from its file\n   - Add to directFunctions map\n\n3. Create add-subtask.js MCP tool in mcp-server/src/tools/:\n   - Import z from zod for parameter schema\n   - Import executeMCPToolAction from ./utils.js\n   - Import addSubtaskDirect from task-master-core.js\n   - Define parameters matching CLI options using zod schema\n   - Implement registerAddSubtaskTool(server) with server.addTool\n   - Use executeMCPToolAction in execute method\n\n4. Register in tools/index.js with tool name 'add_subtask'\n\n5. Add to .cursor/mcp.json with appropriate schema\n\n6. Write tests following testing guidelines:\n   - Unit test for addSubtaskDirect.js\n   - Integration test for MCP tool",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 23
        },
        {
          "id": 27,
          "title": "Implement remove-subtask MCP command",
          "description": "Create direct function wrapper and MCP tool for removing subtasks from tasks.",
          "details": "Following MCP implementation standards:\n\n1. Create removeSubtaskDirect.js in mcp-server/src/core/direct-functions/:\n   - Import removeSubtask from task-manager.js\n   - Handle file paths using findTasksJsonPath utility\n   - Process arguments: parentTaskId, subtaskId\n   - Validate inputs and handle errors with try/catch\n   - Return standardized { success, data/error } object\n\n2. Export from task-master-core.js:\n   - Import the function from its file\n   - Add to directFunctions map\n\n3. Create remove-subtask.js MCP tool in mcp-server/src/tools/:\n   - Import z from zod for parameter schema\n   - Import executeMCPToolAction from ./utils.js\n   - Import removeSubtaskDirect from task-master-core.js\n   - Define parameters matching CLI options using zod schema\n   - Implement registerRemoveSubtaskTool(server) with server.addTool\n   - Use executeMCPToolAction in execute method\n\n4. Register in tools/index.js with tool name 'remove_subtask'\n\n5. Add to .cursor/mcp.json with appropriate schema\n\n6. Write tests following testing guidelines:\n   - Unit test for removeSubtaskDirect.js\n   - Integration test for MCP tool",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 23
        },
        {
          "id": 28,
          "title": "Implement analyze MCP command",
          "description": "Create direct function wrapper and MCP tool for analyzing task complexity.",
          "details": "Following MCP implementation standards:\n\n1. Create analyzeTaskComplexityDirect.js in mcp-server/src/core/direct-functions/:\n   - Import analyzeTaskComplexity from task-manager.js\n   - Handle file paths using findTasksJsonPath utility\n   - Process arguments: taskId\n   - Validate inputs and handle errors with try/catch\n   - Return standardized { success, data/error } object\n\n2. Export from task-master-core.js:\n   - Import the function from its file\n   - Add to directFunctions map\n\n3. Create analyze.js MCP tool in mcp-server/src/tools/:\n   - Import z from zod for parameter schema\n   - Import executeMCPToolAction from ./utils.js\n   - Import analyzeTaskComplexityDirect from task-master-core.js\n   - Define parameters matching CLI options using zod schema\n   - Implement registerAnalyzeTool(server) with server.addTool\n   - Use executeMCPToolAction in execute method\n\n4. Register in tools/index.js with tool name 'analyze'\n\n5. Add to .cursor/mcp.json with appropriate schema\n\n6. Write tests following testing guidelines:\n   - Unit test for analyzeTaskComplexityDirect.js\n   - Integration test for MCP tool",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 23
        },
        {
          "id": 29,
          "title": "Implement clear-subtasks MCP command",
          "description": "Create direct function wrapper and MCP tool for clearing subtasks from a parent task.",
          "details": "Following MCP implementation standards:\n\n1. Create clearSubtasksDirect.js in mcp-server/src/core/direct-functions/:\n   - Import clearSubtasks from task-manager.js\n   - Handle file paths using findTasksJsonPath utility\n   - Process arguments: taskId\n   - Validate inputs and handle errors with try/catch\n   - Return standardized { success, data/error } object\n\n2. Export from task-master-core.js:\n   - Import the function from its file\n   - Add to directFunctions map\n\n3. Create clear-subtasks.js MCP tool in mcp-server/src/tools/:\n   - Import z from zod for parameter schema\n   - Import executeMCPToolAction from ./utils.js\n   - Import clearSubtasksDirect from task-master-core.js\n   - Define parameters matching CLI options using zod schema\n   - Implement registerClearSubtasksTool(server) with server.addTool\n   - Use executeMCPToolAction in execute method\n\n4. Register in tools/index.js with tool name 'clear_subtasks'\n\n5. Add to .cursor/mcp.json with appropriate schema\n\n6. Write tests following testing guidelines:\n   - Unit test for clearSubtasksDirect.js\n   - Integration test for MCP tool",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 23
        },
        {
          "id": 30,
          "title": "Implement expand-all MCP command",
          "description": "Create direct function wrapper and MCP tool for expanding all tasks into subtasks.",
          "details": "Following MCP implementation standards:\n\n1. Create expandAllTasksDirect.js in mcp-server/src/core/direct-functions/:\n   - Import expandAllTasks from task-manager.js\n   - Handle file paths using findTasksJsonPath utility\n   - Process arguments: prompt, num, force, research\n   - Validate inputs and handle errors with try/catch\n   - Return standardized { success, data/error } object\n\n2. Export from task-master-core.js:\n   - Import the function from its file\n   - Add to directFunctions map\n\n3. Create expand-all.js MCP tool in mcp-server/src/tools/:\n   - Import z from zod for parameter schema\n   - Import executeMCPToolAction from ./utils.js\n   - Import expandAllTasksDirect from task-master-core.js\n   - Define parameters matching CLI options using zod schema\n   - Implement registerExpandAllTool(server) with server.addTool\n   - Use executeMCPToolAction in execute method\n\n4. Register in tools/index.js with tool name 'expand_all'\n\n5. Add to .cursor/mcp.json with appropriate schema\n\n6. Write tests following testing guidelines:\n   - Unit test for expandAllTasksDirect.js\n   - Integration test for MCP tool",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 23
        },
        {
          "id": 31,
          "title": "Create Core Direct Function Structure",
          "description": "Set up the modular directory structure for direct functions and update task-master-core.js to act as an import/export hub.",
          "details": "1. Create the mcp-server/src/core/direct-functions/ directory structure\n2. Update task-master-core.js to import and re-export functions from individual files\n3. Create a utils directory for shared utility functions\n4. Implement a standard template for direct function files\n5. Create documentation for the new modular structure\n6. Update existing imports in MCP tools to use the new structure\n7. Create unit tests for the import/export hub functionality\n8. Ensure backward compatibility with any existing code using the old structure",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 23
        },
        {
          "id": 32,
          "title": "Refactor Existing Direct Functions to Modular Structure",
          "description": "Move existing direct function implementations from task-master-core.js to individual files in the new directory structure.",
          "details": "1. Identify all existing direct functions in task-master-core.js\n2. Create individual files for each function in mcp-server/src/core/direct-functions/\n3. Move the implementation to the new files, ensuring consistent error handling\n4. Update imports/exports in task-master-core.js\n5. Create unit tests for each individual function file\n6. Update documentation to reflect the new structure\n7. Ensure all MCP tools reference the functions through task-master-core.js\n8. Verify backward compatibility with existing code",
          "status": "done",
          "dependencies": [
            "23.31"
          ],
          "parentTaskId": 23
        },
        {
          "id": 33,
          "title": "Implement Naming Convention Standards",
          "description": "Update all MCP server components to follow the standardized naming conventions for files, functions, and tools.",
          "details": "1. Audit all existing MCP server files and update file names to use kebab-case (like-this.js)\n2. Refactor direct function names to use camelCase with Direct suffix (functionNameDirect)\n3. Update tool registration functions to use camelCase with Tool suffix (registerToolNameTool)\n4. Ensure all MCP tool names exposed to clients use snake_case (tool_name)\n5. Create a naming convention documentation file for future reference\n6. Update imports/exports in all files to reflect the new naming conventions\n7. Verify that all tools are properly registered with the correct naming pattern\n8. Update tests to reflect the new naming conventions\n9. Create a linting rule to enforce naming conventions in future development",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 23
        },
        {
          "id": 34,
          "title": "Review functionality of all MCP direct functions",
          "description": "Verify that all implemented MCP direct functions work correctly with edge cases",
          "details": "Perform comprehensive testing of all MCP direct function implementations to ensure they handle various input scenarios correctly and return appropriate responses. Check edge cases, error handling, and parameter validation.",
          "status": "in-progress",
          "dependencies": [],
          "parentTaskId": 23
        },
        {
          "id": 35,
          "title": "Review commands.js to ensure all commands are available via MCP",
          "description": "Verify that all CLI commands have corresponding MCP implementations",
          "details": "Compare the commands defined in scripts/modules/commands.js with the MCP tools implemented in mcp-server/src/tools/. Create a list of any commands missing MCP implementations and ensure all command options are properly represented in the MCP parameter schemas.",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 23
        },
        {
          "id": 36,
          "title": "Finish setting up addResearch in index.js",
          "description": "Complete the implementation of addResearch functionality in the MCP server",
          "details": "Implement the addResearch function in the MCP server's index.js file to enable research-backed functionality. This should include proper integration with Perplexity AI and ensure that all MCP tools requiring research capabilities have access to this functionality.",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 23
        },
        {
          "id": 37,
          "title": "Finish setting up addTemplates in index.js",
          "description": "Complete the implementation of addTemplates functionality in the MCP server",
          "details": "Implement the addTemplates function in the MCP server's index.js file to enable template-based generation. Configure proper loading of templates from the appropriate directory and ensure they're accessible to all MCP tools that need to generate formatted content.",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 23
        },
        {
          "id": 38,
          "title": "Implement robust project root handling for file paths",
          "description": "Create a consistent approach for handling project root paths across MCP tools",
          "details": "Analyze and refactor the project root handling mechanism to ensure consistent file path resolution across all MCP direct functions. This should properly handle relative and absolute paths, respect the projectRoot parameter when provided, and have appropriate fallbacks when not specified. Document the approach in a comment within path-utils.js for future maintainers.\n\n<info added on 2025-04-01T02:21:57.137Z>\nHere's additional information addressing the request for research on npm package path handling:\n\n## Path Handling Best Practices for npm Packages\n\n### Distinguishing Package and Project Paths\n\n1. **Package Installation Path**: \n   - Use `require.resolve()` to find paths relative to your package\n   - For global installs, use `process.execPath` to locate the Node.js executable\n\n2. **Project Path**:\n   - Use `process.cwd()` as a starting point\n   - Search upwards for `package.json` or `.git` to find project root\n   - Consider using packages like `find-up` or `pkg-dir` for robust root detection\n\n### Standard Approaches\n\n1. **Detecting Project Root**:\n   - Recursive search for `package.json` or `.git` directory\n   - Use `path.resolve()` to handle relative paths\n   - Fall back to `process.cwd()` if no root markers found\n\n2. **Accessing Package Files**:\n   - Use `__dirname` for paths relative to current script\n   - For files in `node_modules`, use `require.resolve('package-name/path/to/file')`\n\n3. **Separating Package and Project Files**:\n   - Store package-specific files in a dedicated directory (e.g., `.task-master`)\n   - Use environment variables to override default paths\n\n### Cross-Platform Compatibility\n\n1. Use `path.join()` and `path.resolve()` for cross-platform path handling\n2. Avoid hardcoded forward/backslashes in paths\n3. Use `os.homedir()` for user home directory references\n\n### Best Practices for Path Resolution\n\n1. **Absolute vs Relative Paths**:\n   - Always convert relative paths to absolute using `path.resolve()`\n   - Use `path.isAbsolute()` to check if a path is already absolute\n\n2. **Handling Different Installation Scenarios**:\n   - Local dev: Use `process.cwd()` as fallback project root\n   - Local dependency: Resolve paths relative to consuming project\n   - Global install: Use `process.execPath` to locate global `node_modules`\n\n3. **Configuration Options**:\n   - Allow users to specify custom project root via CLI option or config file\n   - Implement a clear precedence order for path resolution (e.g., CLI option > config file > auto-detection)\n\n4. **Error Handling**:\n   - Provide clear error messages when critical paths cannot be resolved\n   - Implement retry logic with alternative methods if primary path detection fails\n\n5. **Documentation**:\n   - Clearly document path handling behavior in README and inline comments\n   - Provide examples for common scenarios and edge cases\n\nBy implementing these practices, the MCP tools can achieve consistent and robust path handling across various npm installation and usage scenarios.\n</info added on 2025-04-01T02:21:57.137Z>\n\n<info added on 2025-04-01T02:25:01.463Z>\nHere's additional information addressing the request for clarification on path handling challenges for npm packages:\n\n## Advanced Path Handling Challenges and Solutions\n\n### Challenges to Avoid\n\n1. **Relying solely on process.cwd()**:\n   - Global installs: process.cwd() could be any directory\n   - Local installs as dependency: points to parent project's root\n   - Users may run commands from subdirectories\n\n2. **Dual Path Requirements**:\n   - Package Path: Where task-master code is installed\n   - Project Path: Where user's tasks.json resides\n\n3. **Specific Edge Cases**:\n   - Non-project directory execution\n   - Deeply nested project structures\n   - Yarn/pnpm workspaces\n   - Monorepos with multiple tasks.json files\n   - Commands invoked from scripts in different directories\n\n### Advanced Solutions\n\n1. **Project Marker Detection**:\n   - Implement recursive search for package.json or .git\n   - Use `find-up` package for efficient directory traversal\n   ```javascript\n   const findUp = require('find-up');\n   const projectRoot = await findUp(dir => findUp.sync('package.json', { cwd: dir }));\n   ```\n\n2. **Package Path Resolution**:\n   - Leverage `import.meta.url` with `fileURLToPath`:\n   ```javascript\n   import { fileURLToPath } from 'url';\n   import path from 'path';\n   \n   const __filename = fileURLToPath(import.meta.url);\n   const __dirname = path.dirname(__filename);\n   const packageRoot = path.resolve(__dirname, '..');\n   ```\n\n3. **Workspace-Aware Resolution**:\n   - Detect Yarn/pnpm workspaces:\n   ```javascript\n   const findWorkspaceRoot = require('find-yarn-workspace-root');\n   const workspaceRoot = findWorkspaceRoot(process.cwd());\n   ```\n\n4. **Monorepo Handling**:\n   - Implement cascading configuration search\n   - Allow multiple tasks.json files with clear precedence rules\n\n5. **CLI Tool Inspiration**:\n   - ESLint: Uses `eslint-find-rule-files` for config discovery\n   - Jest: Implements `jest-resolve` for custom module resolution\n   - Next.js: Uses `find-up` to locate project directories\n\n6. **Robust Path Resolution Algorithm**:\n   ```javascript\n   function resolveProjectRoot(startDir) {\n     const projectMarkers = ['package.json', '.git', 'tasks.json'];\n     let currentDir = startDir;\n     while (currentDir !== path.parse(currentDir).root) {\n       if (projectMarkers.some(marker => fs.existsSync(path.join(currentDir, marker)))) {\n         return currentDir;\n       }\n       currentDir = path.dirname(currentDir);\n     }\n     return startDir; // Fallback to original directory\n   }\n   ```\n\n7. **Environment Variable Overrides**:\n   - Allow users to explicitly set paths:\n   ```javascript\n   const projectRoot = process.env.TASK_MASTER_PROJECT_ROOT || resolveProjectRoot(process.cwd());\n   ```\n\nBy implementing these advanced techniques, task-master can achieve robust path handling across various npm scenarios without requiring manual specification.\n</info added on 2025-04-01T02:25:01.463Z>",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 23
        },
        {
          "id": 39,
          "title": "Implement add-dependency MCP command",
          "description": "Create MCP tool implementation for the add-dependency command",
          "details": "",
          "status": "done",
          "dependencies": [
            "23.31"
          ],
          "parentTaskId": 23
        },
        {
          "id": 40,
          "title": "Implement remove-dependency MCP command",
          "description": "Create MCP tool implementation for the remove-dependency command",
          "details": "",
          "status": "done",
          "dependencies": [
            "23.31"
          ],
          "parentTaskId": 23
        },
        {
          "id": 41,
          "title": "Implement validate-dependencies MCP command",
          "description": "Create MCP tool implementation for the validate-dependencies command",
          "details": "",
          "status": "done",
          "dependencies": [
            "23.31",
            "23.39",
            "23.40"
          ],
          "parentTaskId": 23
        },
        {
          "id": 42,
          "title": "Implement fix-dependencies MCP command",
          "description": "Create MCP tool implementation for the fix-dependencies command",
          "details": "",
          "status": "done",
          "dependencies": [
            "23.31",
            "23.41"
          ],
          "parentTaskId": 23
        },
        {
          "id": 43,
          "title": "Implement complexity-report MCP command",
          "description": "Create MCP tool implementation for the complexity-report command",
          "details": "",
          "status": "done",
          "dependencies": [
            "23.31"
          ],
          "parentTaskId": 23
        },
        {
          "id": 44,
          "title": "Implement init MCP command",
          "description": "Create MCP tool implementation for the init command",
          "details": "",
          "status": "deferred",
          "dependencies": [],
          "parentTaskId": 23
        },
        {
          "id": 45,
          "title": "Support setting env variables through mcp server",
          "description": "currently we need to access the env variables through the env file present in the project (that we either create or find and append to). we could abstract this by allowing users to define the env vars in the mcp.json directly as folks currently do. mcp.json should then be in gitignore if thats the case. but for this i think in fastmcp all we need is to access ENV in a specific way. we need to find that way and then implement it",
          "details": "\n\n<info added on 2025-04-01T01:57:24.160Z>\nTo access environment variables defined in the mcp.json config file when using FastMCP, you can utilize the `Config` class from the `fastmcp` module. Here's how to implement this:\n\n1. Import the necessary module:\n```python\nfrom fastmcp import Config\n```\n\n2. Access environment variables:\n```python\nconfig = Config()\nenv_var = config.env.get(\"VARIABLE_NAME\")\n```\n\nThis approach allows you to retrieve environment variables defined in the mcp.json file directly in your code. The `Config` class automatically loads the configuration, including environment variables, from the mcp.json file.\n\nFor security, ensure that sensitive information in mcp.json is not committed to version control. You can add mcp.json to your .gitignore file to prevent accidental commits.\n\nIf you need to access multiple environment variables, you can do so like this:\n```python\ndb_url = config.env.get(\"DATABASE_URL\")\napi_key = config.env.get(\"API_KEY\")\ndebug_mode = config.env.get(\"DEBUG_MODE\", False)  # With a default value\n```\n\nThis method provides a clean and consistent way to access environment variables defined in the mcp.json configuration file within your FastMCP project.\n</info added on 2025-04-01T01:57:24.160Z>\n\n<info added on 2025-04-01T01:57:49.848Z>\nTo access environment variables defined in the mcp.json config file when using FastMCP in a JavaScript environment, you can use the `fastmcp` npm package. Here's how to implement this:\n\n1. Install the `fastmcp` package:\n```bash\nnpm install fastmcp\n```\n\n2. Import the necessary module:\n```javascript\nconst { Config } = require('fastmcp');\n```\n\n3. Access environment variables:\n```javascript\nconst config = new Config();\nconst envVar = config.env.get('VARIABLE_NAME');\n```\n\nThis approach allows you to retrieve environment variables defined in the mcp.json file directly in your JavaScript code. The `Config` class automatically loads the configuration, including environment variables, from the mcp.json file.\n\nYou can access multiple environment variables like this:\n```javascript\nconst dbUrl = config.env.get('DATABASE_URL');\nconst apiKey = config.env.get('API_KEY');\nconst debugMode = config.env.get('DEBUG_MODE', false); // With a default value\n```\n\nThis method provides a consistent way to access environment variables defined in the mcp.json configuration file within your FastMCP project in a JavaScript environment.\n</info added on 2025-04-01T01:57:49.848Z>",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 23
        },
        {
          "id": 46,
          "title": "adjust rules so it prioritizes mcp commands over script",
          "description": "",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 23
        }
      ]
    },
    {
      "id": 24,
      "title": "Implement AI-Powered Test Generation Command",
      "description": "Create a new 'generate-test' command in Task Master that leverages AI to automatically produce Jest test files for tasks based on their descriptions and subtasks, utilizing Claude API for AI integration.",
      "status": "pending",
      "dependencies": [
        22
      ],
      "priority": "high",
      "details": "Implement a new command in the Task Master CLI that generates comprehensive Jest test files for tasks. The command should be callable as 'task-master generate-test --id=1' and should:\n\n1. Accept a task ID parameter to identify which task to generate tests for\n2. Retrieve the task and its subtasks from the task store\n3. Analyze the task description, details, and subtasks to understand implementation requirements\n4. Construct an appropriate prompt for the AI service using Claude API\n5. Process the AI response to create a well-formatted test file named 'task_XXX.test.ts' where XXX is the zero-padded task ID\n6. Include appropriate test cases that cover the main functionality described in the task\n7. Generate mocks for external dependencies identified in the task description\n8. Create assertions that validate the expected behavior\n9. Handle both parent tasks and subtasks appropriately (for subtasks, name the file 'task_XXX_YYY.test.ts' where YYY is the subtask ID)\n10. Include error handling for API failures, invalid task IDs, etc.\n11. Add appropriate documentation for the command in the help system\n\nThe implementation should utilize the Claude API for AI service integration and maintain consistency with the current command structure and error handling patterns. Consider using TypeScript for better type safety and integration with the Claude API.",
      "testStrategy": "Testing for this feature should include:\n\n1. Unit tests for the command handler function to verify it correctly processes arguments and options\n2. Mock tests for the Claude API integration to ensure proper prompt construction and response handling\n3. Integration tests that verify the end-to-end flow using a mock Claude API response\n4. Tests for error conditions including:\n   - Invalid task IDs\n   - Network failures when contacting the AI service\n   - Malformed AI responses\n   - File system permission issues\n5. Verification that generated test files follow Jest conventions and can be executed\n6. Tests for both parent task and subtask handling\n7. Manual verification of the quality of generated tests by running them against actual task implementations\n\nCreate a test fixture with sample tasks of varying complexity to evaluate the test generation capabilities across different scenarios. The tests should verify that the command outputs appropriate success/error messages to the console and creates files in the expected location with proper content structure.",
      "subtasks": [
        {
          "id": 1,
          "title": "Create command structure for 'generate-test'",
          "description": "Implement the basic structure for the 'generate-test' command, including command registration, parameter validation, and help documentation.",
          "dependencies": [],
          "details": "Implementation steps:\n1. Create a new file `src/commands/generate-test.ts`\n2. Implement the command structure following the pattern of existing commands\n3. Register the new command in the CLI framework\n4. Add command options for task ID (--id=X) parameter\n5. Implement parameter validation to ensure a valid task ID is provided\n6. Add help documentation for the command\n7. Create the basic command flow that retrieves the task from the task store\n8. Implement error handling for invalid task IDs and other basic errors\n\nTesting approach:\n- Test command registration\n- Test parameter validation (missing ID, invalid ID format)\n- Test error handling for non-existent task IDs\n- Test basic command flow with a mock task store",
          "status": "pending",
          "parentTaskId": 24
        },
        {
          "id": 2,
          "title": "Implement AI prompt construction and FastMCP integration",
          "description": "Develop the logic to analyze tasks, construct appropriate AI prompts, and interact with the AI service using FastMCP to generate test content.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Create a utility function to analyze task descriptions and subtasks for test requirements\n2. Implement a prompt builder that formats task information into an effective AI prompt\n3. Use FastMCP to send the prompt and receive the response\n4. Process the FastMCP response to extract the generated test code\n5. Implement error handling for FastMCP failures, rate limits, and malformed responses\n6. Add appropriate logging for the FastMCP interaction process\n\nTesting approach:\n- Test prompt construction with various task types\n- Test FastMCP integration with mocked responses\n- Test error handling for FastMCP failures\n- Test response processing with sample FastMCP outputs",
          "status": "pending",
          "parentTaskId": 24
        },
        {
          "id": 3,
          "title": "Implement test file generation and output",
          "description": "Create functionality to format AI-generated tests into proper Jest test files and save them to the appropriate location.",
          "dependencies": [
            2
          ],
          "details": "Implementation steps:\n1. Create a utility to format the FastMCP response into a well-structured Jest test file\n2. Implement naming logic for test files (task_XXX.test.ts for parent tasks, task_XXX_YYY.test.ts for subtasks)\n3. Add logic to determine the appropriate file path for saving the test\n4. Implement file system operations to write the test file\n5. Add validation to ensure the generated test follows Jest conventions\n6. Implement formatting of the test file for consistency with project coding standards\n7. Add user feedback about successful test generation and file location\n8. Implement handling for both parent tasks and subtasks\n\nTesting approach:\n- Test file naming logic for various task/subtask combinations\n- Test file content formatting with sample FastMCP outputs\n- Test file system operations with mocked fs module\n- Test the complete flow from command input to file output\n- Verify generated tests can be executed by Jest",
          "status": "pending",
          "parentTaskId": 24
        }
      ]
    },
    {
      "id": 25,
      "title": "Implement 'add-subtask' Command for Task Hierarchy Management",
      "description": "Create a command-line interface command that allows users to manually add subtasks to existing tasks, establishing a parent-child relationship between tasks.",
      "status": "done",
      "dependencies": [
        3
      ],
      "priority": "medium",
      "details": "Implement the 'add-subtask' command that enables users to create hierarchical relationships between tasks. The command should:\n\n1. Accept parameters for the parent task ID and either the details for a new subtask or the ID of an existing task to convert to a subtask\n2. Validate that the parent task exists before proceeding\n3. If creating a new subtask, collect all necessary task information (title, description, due date, etc.)\n4. If converting an existing task, ensure it's not already a subtask of another task\n5. Update the data model to support parent-child relationships between tasks\n6. Modify the task storage mechanism to persist these relationships\n7. Ensure that when a parent task is marked complete, there's appropriate handling of subtasks (prompt user or provide options)\n8. Update the task listing functionality to display subtasks with appropriate indentation or visual hierarchy\n9. Implement proper error handling for cases like circular dependencies (a task cannot be a subtask of its own subtask)\n10. Document the command syntax and options in the help system",
      "testStrategy": "Testing should verify both the functionality and edge cases of the subtask implementation:\n\n1. Unit tests:\n   - Test adding a new subtask to an existing task\n   - Test converting an existing task to a subtask\n   - Test validation logic for parent task existence\n   - Test prevention of circular dependencies\n   - Test error handling for invalid inputs\n\n2. Integration tests:\n   - Verify subtask relationships are correctly persisted to storage\n   - Verify subtasks appear correctly in task listings\n   - Test the complete workflow from adding a subtask to viewing it in listings\n\n3. Edge cases:\n   - Attempt to add a subtask to a non-existent parent\n   - Attempt to make a task a subtask of itself\n   - Attempt to create circular dependencies (A  B  A)\n   - Test with a deep hierarchy of subtasks (A  B  C  D)\n   - Test handling of subtasks when parent tasks are deleted\n   - Verify behavior when marking parent tasks as complete\n\n4. Manual testing:\n   - Verify command usability and clarity of error messages\n   - Test the command with various parameter combinations",
      "subtasks": [
        {
          "id": 1,
          "title": "Update Data Model to Support Parent-Child Task Relationships",
          "description": "Modify the task data structure to support hierarchical relationships between tasks",
          "dependencies": [],
          "details": "1. Examine the current task data structure in scripts/modules/task-manager.js\n2. Add a 'parentId' field to the task object schema to reference parent tasks\n3. Add a 'subtasks' array field to store references to child tasks\n4. Update any relevant validation functions to account for these new fields\n5. Ensure serialization and deserialization of tasks properly handles these new fields\n6. Update the storage mechanism to persist these relationships\n7. Test by manually creating tasks with parent-child relationships and verifying they're saved correctly\n8. Write unit tests to verify the updated data model works as expected",
          "status": "done",
          "parentTaskId": 25
        },
        {
          "id": 2,
          "title": "Implement Core addSubtask Function in task-manager.js",
          "description": "Create the core function that handles adding subtasks to parent tasks",
          "dependencies": [
            1
          ],
          "details": "1. Create a new addSubtask function in scripts/modules/task-manager.js\n2. Implement logic to validate that the parent task exists\n3. Add functionality to handle both creating new subtasks and converting existing tasks\n4. For new subtasks: collect task information and create a new task with parentId set\n5. For existing tasks: validate it's not already a subtask and update its parentId\n6. Add validation to prevent circular dependencies (a task cannot be a subtask of its own subtask)\n7. Update the parent task's subtasks array\n8. Ensure proper error handling with descriptive error messages\n9. Export the function for use by the command handler\n10. Write unit tests to verify all scenarios (new subtask, converting task, error cases)",
          "status": "done",
          "parentTaskId": 25
        },
        {
          "id": 3,
          "title": "Implement add-subtask Command in commands.js",
          "description": "Create the command-line interface for the add-subtask functionality",
          "dependencies": [
            2
          ],
          "details": "1. Add a new command registration in scripts/modules/commands.js following existing patterns\n2. Define command syntax: 'add-subtask <parentId> [--task-id=<taskId> | --title=<title>]'\n3. Implement command handler that calls the addSubtask function from task-manager.js\n4. Add interactive prompts to collect required information when not provided as arguments\n5. Implement validation for command arguments\n6. Add appropriate success and error messages\n7. Document the command syntax and options in the help system\n8. Test the command with various input combinations\n9. Ensure the command follows the same patterns as other commands like add-dependency",
          "status": "done",
          "parentTaskId": 25
        },
        {
          "id": 4,
          "title": "Create Unit Test for add-subtask",
          "description": "Develop comprehensive unit tests for the add-subtask functionality",
          "dependencies": [
            2,
            3
          ],
          "details": "1. Create a test file in tests/unit/ directory for the add-subtask functionality\n2. Write tests for the addSubtask function in task-manager.js\n3. Test all key scenarios: adding new subtasks, converting existing tasks to subtasks\n4. Test error cases: non-existent parent task, circular dependencies, invalid input\n5. Use Jest mocks to isolate the function from file system operations\n6. Test the command handler in isolation using mock functions\n7. Ensure test coverage for all branches and edge cases\n8. Document the testing approach for future reference",
          "status": "done",
          "parentTaskId": 25
        },
        {
          "id": 5,
          "title": "Implement remove-subtask Command",
          "description": "Create functionality to remove a subtask from its parent, following the same approach as add-subtask",
          "dependencies": [
            2,
            3
          ],
          "details": "1. Create a removeSubtask function in scripts/modules/task-manager.js\n2. Implement logic to validate the subtask exists and is actually a subtask\n3. Add options to either delete the subtask completely or convert it to a standalone task\n4. Update the parent task's subtasks array to remove the reference\n5. If converting to standalone task, clear the parentId reference\n6. Implement the remove-subtask command in scripts/modules/commands.js following patterns from add-subtask\n7. Add appropriate validation and error messages\n8. Document the command in the help system\n9. Export the function in task-manager.js\n10. Ensure proper error handling for all scenarios",
          "status": "done",
          "parentTaskId": 25
        }
      ]
    },
    {
      "id": 26,
      "title": "Implement Context Foundation for AI Operations",
      "description": "Implement the foundation for context integration in Task Master, enabling AI operations to leverage file-based context, cursor rules, and basic code context to improve generated outputs.",
      "status": "pending",
      "dependencies": [
        5,
        6,
        7
      ],
      "priority": "high",
      "details": "Create a Phase 1 foundation for context integration in Task Master that provides immediate practical value:\n\n1. Add `--context-file` Flag to AI Commands:\n   - Add a consistent `--context-file <file>` option to all AI-related commands (expand, update, add-task, etc.)\n   - Implement file reading functionality that loads content from the specified file\n   - Add content integration into Claude API prompts with appropriate formatting\n   - Handle error conditions such as file not found gracefully\n   - Update help documentation to explain the new option\n\n2. Implement Cursor Rules Integration for Context:\n   - Create a `--context-rules <rules>` option for all AI commands\n   - Implement functionality to extract content from specified .cursor/rules/*.mdc files\n   - Support comma-separated lists of rule names and \"all\" option\n   - Add validation and error handling for non-existent rules\n   - Include helpful examples in command help output\n\n3. Implement Basic Context File Extraction Utility:\n   - Create utility functions in utils.js for reading context from files\n   - Add proper error handling and logging\n   - Implement content validation to ensure reasonable size limits\n   - Add content truncation if files exceed token limits\n   - Create helper functions for formatting context additions properly\n\n4. Update Command Handler Logic:\n   - Modify command handlers to support the new context options\n   - Update prompt construction to incorporate context content\n   - Ensure backwards compatibility with existing commands\n   - Add logging for context inclusion to aid troubleshooting\n\nThe focus of this phase is to provide immediate value with straightforward implementations that enable users to include relevant context in their AI operations.",
      "testStrategy": "Testing should verify that the context foundation works as expected and adds value:\n\n1. Functional Tests:\n   - Verify `--context-file` flag correctly reads and includes content from specified files\n   - Test that `--context-rules` correctly extracts and formats content from cursor rules\n   - Test with both existing and non-existent files/rules to verify error handling\n   - Verify content truncation works appropriately for large files\n\n2. Integration Tests:\n   - Test each AI-related command with context options\n   - Verify context is properly included in API calls to Claude\n   - Test combinations of multiple context options\n   - Verify help documentation includes the new options\n\n3. Usability Testing:\n   - Create test scenarios that show clear improvement in AI output quality with context\n   - Compare outputs with and without context to measure impact\n   - Document examples of effective context usage for the user documentation\n\n4. Error Handling:\n   - Test invalid file paths and rule names\n   - Test oversized context files\n   - Verify appropriate error messages guide users to correct usage\n\nThe testing focus should be on proving immediate value to users while ensuring robust error handling.",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement --context-file Flag for AI Commands",
          "description": "Add the --context-file <file> option to all AI-related commands and implement file reading functionality",
          "details": "1. Update the contextOptions array in commands.js to include the --context-file option\\n2. Modify AI command action handlers to check for the context-file option\\n3. Implement file reading functionality that loads content from the specified file\\n4. Add content integration into Claude API prompts with appropriate formatting\\n5. Add error handling for file not found or permission issues\\n6. Update help documentation to explain the new option with examples",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 26
        },
        {
          "id": 2,
          "title": "Implement --context Flag for AI Commands",
          "description": "Add support for directly passing context in the command line",
          "details": "1. Update AI command options to include a --context option\\n2. Modify action handlers to process context from command line\\n3. Sanitize and truncate long context inputs\\n4. Add content integration into Claude API prompts\\n5. Update help documentation to explain the new option with examples",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 26
        },
        {
          "id": 3,
          "title": "Implement Cursor Rules Integration for Context",
          "description": "Create a --context-rules option for all AI commands that extracts content from specified .cursor/rules/*.mdc files",
          "details": "1. Add --context-rules <rules> option to all AI-related commands\\n2. Implement functionality to extract content from specified .cursor/rules/*.mdc files\\n3. Support comma-separated lists of rule names and 'all' option\\n4. Add validation and error handling for non-existent rules\\n5. Include helpful examples in command help output",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 26
        },
        {
          "id": 4,
          "title": "Implement Basic Context File Extraction Utility",
          "description": "Create utility functions for reading context from files with error handling and content validation",
          "details": "1. Create utility functions in utils.js for reading context from files\\n2. Add proper error handling and logging for file access issues\\n3. Implement content validation to ensure reasonable size limits\\n4. Add content truncation if files exceed token limits\\n5. Create helper functions for formatting context additions properly\\n6. Document the utility functions with clear examples",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 26
        }
      ]
    },
    {
      "id": 27,
      "title": "Implement Context Enhancements for AI Operations",
      "description": "Enhance the basic context integration with more sophisticated code context extraction, task history awareness, and PRD integration to provide richer context for AI operations.",
      "status": "pending",
      "dependencies": [
        26
      ],
      "priority": "high",
      "details": "Building upon the foundational context implementation in Task #26, implement Phase 2 context enhancements:\n\n1. Add Code Context Extraction Feature:\n   - Create a `--context-code <pattern>` option for all AI commands\n   - Implement glob-based file matching to extract code from specified patterns\n   - Create intelligent code parsing to extract most relevant sections (function signatures, classes, exports)\n   - Implement token usage optimization by selecting key structural elements\n   - Add formatting for code context with proper file paths and syntax indicators\n\n2. Implement Task History Context:\n   - Add a `--context-tasks <ids>` option for AI commands\n   - Support comma-separated task IDs and a \"similar\" option to find related tasks\n   - Create functions to extract context from specified tasks or find similar tasks\n   - Implement formatting for task context with clear section markers\n   - Add validation and error handling for non-existent task IDs\n\n3. Add PRD Context Integration:\n   - Create a `--context-prd <file>` option for AI commands\n   - Implement PRD text extraction and intelligent summarization\n   - Add formatting for PRD context with appropriate section markers\n   - Integrate with the existing PRD parsing functionality from Task #6\n\n4. Improve Context Formatting and Integration:\n   - Create a standardized context formatting system\n   - Implement type-based sectioning for different context sources\n   - Add token estimation for different context types to manage total prompt size\n   - Enhance prompt templates to better integrate various context types\n\nThese enhancements will provide significantly richer context for AI operations, resulting in more accurate and relevant outputs while remaining practical to implement.",
      "testStrategy": "Testing should verify the enhanced context functionality:\n\n1. Code Context Testing:\n   - Verify pattern matching works for different glob patterns\n   - Test code extraction with various file types and sizes\n   - Verify intelligent parsing correctly identifies important code elements\n   - Test token optimization by comparing full file extraction vs. optimized extraction\n   - Check code formatting in prompts sent to Claude API\n\n2. Task History Testing:\n   - Test with different combinations of task IDs\n   - Verify \"similar\" option correctly identifies relevant tasks\n   - Test with non-existent task IDs to ensure proper error handling\n   - Verify formatting and integration in prompts\n\n3. PRD Context Testing:\n   - Test with various PRD files of different sizes\n   - Verify summarization functions correctly when PRDs are too large\n   - Test integration with prompts and formatting\n\n4. Performance Testing:\n   - Measure the impact of context enrichment on command execution time\n   - Test with large code bases to ensure reasonable performance\n   - Verify token counting and optimization functions work as expected\n\n5. Quality Assessment:\n   - Compare AI outputs with Phase 1 vs. Phase 2 context to measure improvements\n   - Create test cases that specifically benefit from code context\n   - Create test cases that benefit from task history context\n\nFocus testing on practical use cases that demonstrate clear improvements in AI-generated outputs.",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Code Context Extraction Feature",
          "description": "Create a --context-code <pattern> option for AI commands and implement glob-based file matching to extract relevant code sections",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 27
        },
        {
          "id": 2,
          "title": "Implement Task History Context Integration",
          "description": "Add a --context-tasks option for AI commands that supports finding and extracting context from specified or similar tasks",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 27
        },
        {
          "id": 3,
          "title": "Add PRD Context Integration",
          "description": "Implement a --context-prd option for AI commands that extracts and formats content from PRD files",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 27
        },
        {
          "id": 4,
          "title": "Create Standardized Context Formatting System",
          "description": "Implement a consistent formatting system for different context types with section markers and token optimization",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 27
        }
      ]
    },
    {
      "id": 28,
      "title": "Implement Advanced ContextManager System",
      "description": "Create a comprehensive ContextManager class to unify context handling with advanced features like context optimization, prioritization, and intelligent context selection.",
      "status": "pending",
      "dependencies": [
        26,
        27
      ],
      "priority": "high",
      "details": "Building on Phase 1 and Phase 2 context implementations, develop Phase 3 advanced context management:\n\n1. Implement the ContextManager Class:\n   - Create a unified `ContextManager` class that encapsulates all context functionality\n   - Implement methods for gathering context from all supported sources\n   - Create a configurable context priority system to favor more relevant context types\n   - Add token management to ensure context fits within API limits\n   - Implement caching for frequently used context to improve performance\n\n2. Create Context Optimization Pipeline:\n   - Develop intelligent context optimization algorithms\n   - Implement type-based truncation strategies (code vs. text)\n   - Create relevance scoring to prioritize most useful context portions\n   - Add token budget allocation that divides available tokens among context types\n   - Implement dynamic optimization based on operation type\n\n3. Add Command Interface Enhancements:\n   - Create the `--context-all` flag to include all available context\n   - Add the `--context-max-tokens <tokens>` option to control token allocation\n   - Implement unified context options across all AI commands\n   - Add intelligent default values for different command types\n\n4. Integrate with AI Services:\n   - Update the AI service integration to use the ContextManager\n   - Create specialized context assembly for different AI operations\n   - Add post-processing to capture new context from AI responses\n   - Implement adaptive context selection based on operation success\n\n5. Add Performance Monitoring:\n   - Create context usage statistics tracking\n   - Implement logging for context selection decisions\n   - Add warnings for context token limits\n   - Create troubleshooting utilities for context-related issues\n\nThe ContextManager system should provide a powerful but easy-to-use interface for both users and developers, maintaining backward compatibility with earlier phases while adding substantial new capabilities.",
      "testStrategy": "Testing should verify both the functionality and performance of the advanced context management:\n\n1. Unit Testing:\n   - Test all ContextManager class methods with various inputs\n   - Verify optimization algorithms maintain critical information\n   - Test caching mechanisms for correctness and efficiency\n   - Verify token allocation and budgeting functions\n   - Test each context source integration separately\n\n2. Integration Testing:\n   - Verify ContextManager integration with AI services\n   - Test with all AI-related commands\n   - Verify backward compatibility with existing context options\n   - Test context prioritization across multiple context types\n   - Verify logging and error handling\n\n3. Performance Testing:\n   - Benchmark context gathering and optimization times\n   - Test with large and complex context sources\n   - Measure impact of caching on repeated operations\n   - Verify memory usage remains acceptable\n   - Test with token limits of different sizes\n\n4. Quality Assessment:\n   - Compare AI outputs using Phase 3 vs. earlier context handling\n   - Measure improvements in context relevance and quality\n   - Test complex scenarios requiring multiple context types\n   - Quantify the impact on token efficiency\n\n5. User Experience Testing:\n   - Verify CLI options are intuitive and well-documented\n   - Test error messages are helpful for troubleshooting\n   - Ensure log output provides useful insights\n   - Test all convenience options like `--context-all`\n\nCreate automated test suites for regression testing of the complete context system.",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Core ContextManager Class Structure",
          "description": "Create a unified ContextManager class that encapsulates all context functionality with methods for gathering context from supported sources",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 28
        },
        {
          "id": 2,
          "title": "Develop Context Optimization Pipeline",
          "description": "Create intelligent algorithms for context optimization including type-based truncation, relevance scoring, and token budget allocation",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 28
        },
        {
          "id": 3,
          "title": "Create Command Interface Enhancements",
          "description": "Add unified context options to all AI commands including --context-all flag and --context-max-tokens for controlling allocation",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 28
        },
        {
          "id": 4,
          "title": "Integrate ContextManager with AI Services",
          "description": "Update AI service integration to use the ContextManager with specialized context assembly for different operations",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 28
        },
        {
          "id": 5,
          "title": "Implement Performance Monitoring and Metrics",
          "description": "Create a system for tracking context usage statistics, logging selection decisions, and providing troubleshooting utilities",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 28
        }
      ]
    },
    {
      "id": 29,
      "title": "Update Claude 3.7 Sonnet Integration with Beta Header for 128k Token Output",
      "description": "Modify the ai-services.js file to include the beta header 'output-128k-2025-02-19' in Claude 3.7 Sonnet API requests to increase the maximum output token length to 128k tokens.",
      "status": "done",
      "dependencies": [],
      "priority": "medium",
      "details": "The task involves updating the Claude 3.7 Sonnet integration in the ai-services.js file to take advantage of the new 128k token output capability. Specifically:\n\n1. Locate the Claude 3.7 Sonnet API request configuration in ai-services.js\n2. Add the beta header 'output-128k-2025-02-19' to the request headers\n3. Update any related configuration parameters that might need adjustment for the increased token limit\n4. Ensure that token counting and management logic is updated to account for the new 128k token output limit\n5. Update any documentation comments in the code to reflect the new capability\n6. Consider implementing a configuration option to enable/disable this feature, as it may be a beta feature subject to change\n7. Verify that the token management logic correctly handles the increased limit without causing unexpected behavior\n8. Ensure backward compatibility with existing code that might assume lower token limits\n\nThe implementation should be clean and maintainable, with appropriate error handling for cases where the beta header might not be supported in the future.",
      "testStrategy": "Testing should verify that the beta header is correctly included and that the system properly handles the increased token limit:\n\n1. Unit test: Verify that the API request to Claude 3.7 Sonnet includes the 'output-128k-2025-02-19' header\n2. Integration test: Make an actual API call to Claude 3.7 Sonnet with the beta header and confirm a successful response\n3. Test with a prompt designed to generate a very large response (>20k tokens but <128k tokens) and verify it completes successfully\n4. Test the token counting logic with mock responses of various sizes to ensure it correctly handles responses approaching the 128k limit\n5. Verify error handling by simulating API errors related to the beta header\n6. Test any configuration options for enabling/disabling the feature\n7. Performance test: Measure any impact on response time or system resources when handling very large responses\n8. Regression test: Ensure existing functionality using Claude 3.7 Sonnet continues to work as expected\n\nDocument all test results, including any limitations or edge cases discovered during testing."
    },
    {
      "id": 30,
      "title": "Enhance parse-prd Command to Support Default PRD Path",
      "description": "Modify the parse-prd command to automatically use a default PRD path when no path is explicitly provided, improving user experience by reducing the need for manual path specification.",
      "status": "done",
      "dependencies": [],
      "priority": "medium",
      "details": "Currently, the parse-prd command requires users to explicitly specify the path to the PRD document. This enhancement should:\n\n1. Implement a default PRD path configuration that can be set in the application settings or configuration file.\n2. Update the parse-prd command to check for this default path when no path argument is provided.\n3. Add a configuration option that allows users to set/update the default PRD path through a command like `config set default-prd-path <path>`.\n4. Ensure backward compatibility by maintaining support for explicit path specification.\n5. Add appropriate error handling for cases where the default path is not set or the file doesn't exist.\n6. Update the command's help text to indicate that a default path will be used if none is specified.\n7. Consider implementing path validation to ensure the default path points to a valid PRD document.\n8. If multiple PRD formats are supported (Markdown, PDF, etc.), ensure the default path handling works with all supported formats.\n9. Add logging for default path usage to help with debugging and usage analytics.",
      "testStrategy": "1. Unit tests:\n   - Test that the command correctly uses the default path when no path is provided\n   - Test that explicit paths override the default path\n   - Test error handling when default path is not set\n   - Test error handling when default path is set but file doesn't exist\n\n2. Integration tests:\n   - Test the full workflow of setting a default path and then using the parse-prd command without arguments\n   - Test with various file formats if multiple are supported\n\n3. Manual testing:\n   - Verify the command works in a real environment with actual PRD documents\n   - Test the user experience of setting and using default paths\n   - Verify help text correctly explains the default path behavior\n\n4. Edge cases to test:\n   - Relative vs. absolute paths for default path setting\n   - Path with special characters or spaces\n   - Very long paths approaching system limits\n   - Permissions issues with the default path location"
    },
    {
      "id": 31,
      "title": "Add Config Flag Support to task-master init Command",
      "description": "Enhance the 'task-master init' command to accept configuration flags that allow users to bypass the interactive CLI questions and directly provide configuration values.",
      "status": "done",
      "dependencies": [],
      "priority": "low",
      "details": "Currently, the 'task-master init' command prompts users with a series of questions to set up the configuration. This task involves modifying the init command to accept command-line flags that can pre-populate these configuration values, allowing for a non-interactive setup process.\n\nImplementation steps:\n1. Identify all configuration options that are currently collected through CLI prompts during initialization\n2. Create corresponding command-line flags for each configuration option (e.g., --project-name, --ai-provider, etc.)\n3. Modify the init command handler to check for these flags before starting the interactive prompts\n4. If a flag is provided, skip the corresponding prompt and use the provided value instead\n5. If all required configuration values are provided via flags, skip the interactive process entirely\n6. Update the command's help text to document all available flags and their usage\n7. Ensure backward compatibility so the command still works with the interactive approach when no flags are provided\n8. Consider adding a --non-interactive flag that will fail if any required configuration is missing rather than prompting for it (useful for scripts and CI/CD)\n\nThe implementation should follow the existing command structure and use the same configuration file format. Make sure to validate flag values with the same validation logic used for interactive inputs.",
      "testStrategy": "Testing should verify both the interactive and non-interactive paths work correctly:\n\n1. Unit tests:\n   - Test each flag individually to ensure it correctly overrides the corresponding prompt\n   - Test combinations of flags to ensure they work together properly\n   - Test validation of flag values to ensure invalid values are rejected\n   - Test the --non-interactive flag to ensure it fails when required values are missing\n\n2. Integration tests:\n   - Test a complete initialization with all flags provided\n   - Test partial initialization with some flags and some interactive prompts\n   - Test initialization with no flags (fully interactive)\n\n3. Manual testing scenarios:\n   - Run 'task-master init --project-name=\"Test Project\" --ai-provider=\"openai\"' and verify it skips those prompts\n   - Run 'task-master init --help' and verify all flags are documented\n   - Run 'task-master init --non-interactive' without required flags and verify it fails with a helpful error message\n   - Run a complete non-interactive initialization and verify the resulting configuration file matches expectations\n\nEnsure the command's documentation is updated to reflect the new functionality, and verify that the help text accurately describes all available options."
    },
    {
      "id": 32,
      "title": "Implement \"learn\" Command for Automatic Cursor Rule Generation",
      "description": "Create a new \"learn\" command that analyzes Cursor's chat history and code changes to automatically generate or update rule files in the .cursor/rules directory, following the cursor_rules.mdc template format. This command will help Cursor autonomously improve its ability to follow development standards by learning from successful implementations.",
      "status": "pending",
      "dependencies": [],
      "priority": "high",
      "details": "Implement a new command in the task-master CLI that enables Cursor to learn from successful coding patterns and chat interactions:\n\nKey Components:\n1. Cursor Data Analysis\n   - Access and parse Cursor's chat history from ~/Library/Application Support/Cursor/User/History\n   - Extract relevant patterns, corrections, and successful implementations\n   - Track file changes and their associated chat context\n\n2. Rule Management\n   - Use cursor_rules.mdc as the template for all rule file formatting\n   - Manage rule files in .cursor/rules directory\n   - Support both creation and updates of rule files\n   - Categorize rules based on context (testing, components, API, etc.)\n\n3. AI Integration\n   - Utilize ai-services.js to interact with Claude\n   - Provide comprehensive context including:\n     * Relevant chat history showing the evolution of solutions\n     * Code changes and their outcomes\n     * Existing rules and template structure\n   - Generate or update rules while maintaining template consistency\n\n4. Implementation Requirements:\n   - Automatic triggering after task completion (configurable)\n   - Manual triggering via CLI command\n   - Proper error handling for missing or corrupt files\n   - Validation against cursor_rules.mdc template\n   - Performance optimization for large histories\n   - Clear logging and progress indication\n\n5. Key Files:\n   - commands/learn.js: Main command implementation\n   - rules/cursor-rules-manager.js: Rule file management\n   - utils/chat-history-analyzer.js: Cursor chat analysis\n   - index.js: Command registration\n\n6. Security Considerations:\n   - Safe file system operations\n   - Proper error handling for inaccessible files\n   - Validation of generated rules\n   - Backup of existing rules before updates",
      "testStrategy": "1. Unit Tests:\n   - Test each component in isolation:\n     * Chat history extraction and analysis\n     * Rule file management and validation\n     * Pattern detection and categorization\n     * Template validation logic\n   - Mock file system operations and AI responses\n   - Test error handling and edge cases\n\n2. Integration Tests:\n   - End-to-end command execution\n   - File system interactions\n   - AI service integration\n   - Rule generation and updates\n   - Template compliance validation\n\n3. Manual Testing:\n   - Test after completing actual development tasks\n   - Verify rule quality and usefulness\n   - Check template compliance\n   - Validate performance with large histories\n   - Test automatic and manual triggering\n\n4. Validation Criteria:\n   - Generated rules follow cursor_rules.mdc format\n   - Rules capture meaningful patterns\n   - Performance remains acceptable\n   - Error handling works as expected\n   - Generated rules improve Cursor's effectiveness",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Initial File Structure",
          "description": "Set up the basic file structure for the learn command implementation",
          "details": "Create the following files with basic exports:\n- commands/learn.js\n- rules/cursor-rules-manager.js\n- utils/chat-history-analyzer.js\n- utils/cursor-path-helper.js",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement Cursor Path Helper",
          "description": "Create utility functions to handle Cursor's application data paths",
          "details": "In utils/cursor-path-helper.js implement:\n- getCursorAppDir(): Returns ~/Library/Application Support/Cursor\n- getCursorHistoryDir(): Returns User/History path\n- getCursorLogsDir(): Returns logs directory path\n- validatePaths(): Ensures required directories exist",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Create Chat History Analyzer Base",
          "description": "Create the base structure for analyzing Cursor's chat history",
          "details": "In utils/chat-history-analyzer.js create:\n- ChatHistoryAnalyzer class\n- readHistoryDir(): Lists all history directories\n- readEntriesJson(): Parses entries.json files\n- parseHistoryEntry(): Extracts relevant data from .js files",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Implement Chat History Extraction",
          "description": "Add core functionality to extract relevant chat history",
          "details": "In ChatHistoryAnalyzer add:\n- extractChatHistory(startTime): Gets history since task start\n- parseFileChanges(): Extracts code changes\n- parseAIInteractions(): Extracts AI responses\n- filterRelevantHistory(): Removes irrelevant entries",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Create CursorRulesManager Base",
          "description": "Set up the base structure for managing Cursor rules",
          "details": "In rules/cursor-rules-manager.js create:\n- CursorRulesManager class\n- readTemplate(): Reads cursor_rules.mdc\n- listRuleFiles(): Lists all .mdc files\n- readRuleFile(): Reads specific rule file",
          "status": "pending"
        },
        {
          "id": 6,
          "title": "Implement Template Validation",
          "description": "Add validation logic for rule files against cursor_rules.mdc",
          "details": "In CursorRulesManager add:\n- validateRuleFormat(): Checks against template\n- parseTemplateStructure(): Extracts template sections\n- validateAgainstTemplate(): Validates content structure\n- getRequiredSections(): Lists mandatory sections",
          "status": "pending"
        },
        {
          "id": 7,
          "title": "Add Rule Categorization Logic",
          "description": "Implement logic to categorize changes into rule files",
          "details": "In CursorRulesManager add:\n- categorizeChanges(): Maps changes to rule files\n- detectRuleCategories(): Identifies relevant categories\n- getRuleFileForPattern(): Maps patterns to files\n- createNewRuleFile(): Initializes new rule files",
          "status": "pending"
        },
        {
          "id": 8,
          "title": "Implement Pattern Analysis",
          "description": "Create functions to analyze implementation patterns",
          "details": "In ChatHistoryAnalyzer add:\n- extractPatterns(): Finds success patterns\n- extractCorrections(): Finds error corrections\n- findSuccessfulPaths(): Tracks successful implementations\n- analyzeDecisions(): Extracts key decisions",
          "status": "pending"
        },
        {
          "id": 9,
          "title": "Create AI Prompt Builder",
          "description": "Implement prompt construction for Claude",
          "details": "In learn.js create:\n- buildRuleUpdatePrompt(): Builds Claude prompt\n- formatHistoryContext(): Formats chat history\n- formatRuleContext(): Formats current rules\n- buildInstructions(): Creates specific instructions",
          "status": "pending"
        },
        {
          "id": 10,
          "title": "Implement Learn Command Core",
          "description": "Create the main learn command implementation",
          "details": "In commands/learn.js implement:\n- learnCommand(): Main command function\n- processRuleUpdates(): Handles rule updates\n- generateSummary(): Creates learning summary\n- handleErrors(): Manages error cases",
          "status": "pending"
        },
        {
          "id": 11,
          "title": "Add Auto-trigger Support",
          "description": "Implement automatic learning after task completion",
          "details": "Update task-manager.js:\n- Add autoLearnConfig handling\n- Modify completeTask() to trigger learning\n- Add learning status tracking\n- Implement learning queue",
          "status": "pending"
        },
        {
          "id": 12,
          "title": "Implement CLI Integration",
          "description": "Add the learn command to the CLI",
          "details": "Update index.js to:\n- Register learn command\n- Add command options\n- Handle manual triggers\n- Process command flags",
          "status": "pending"
        },
        {
          "id": 13,
          "title": "Add Progress Logging",
          "description": "Implement detailed progress logging",
          "details": "Create utils/learn-logger.js with:\n- logLearningProgress(): Tracks overall progress\n- logRuleUpdates(): Tracks rule changes\n- logErrors(): Handles error logging\n- createSummary(): Generates final report",
          "status": "pending"
        },
        {
          "id": 14,
          "title": "Implement Error Recovery",
          "description": "Add robust error handling throughout the system",
          "details": "Create utils/error-handler.js with:\n- handleFileErrors(): Manages file system errors\n- handleParsingErrors(): Manages parsing failures\n- handleAIErrors(): Manages Claude API errors\n- implementRecoveryStrategies(): Adds recovery logic",
          "status": "pending"
        },
        {
          "id": 15,
          "title": "Add Performance Optimization",
          "description": "Optimize performance for large histories",
          "details": "Add to utils/performance-optimizer.js:\n- implementCaching(): Adds result caching\n- optimizeFileReading(): Improves file reading\n- addProgressiveLoading(): Implements lazy loading\n- addMemoryManagement(): Manages memory usage",
          "status": "pending"
        }
      ]
    },
    {
      "id": 33,
      "title": "Create and Integrate Windsurf Rules Document from MDC Files",
      "description": "Develop functionality to generate a .windsurfrules document by combining and refactoring content from three primary .mdc files used for Cursor Rules, ensuring it's properly integrated into the initialization pipeline.",
      "status": "done",
      "dependencies": [],
      "priority": "medium",
      "details": "This task involves creating a mechanism to generate a Windsurf-specific rules document by combining three existing MDC (Markdown Content) files that are currently used for Cursor Rules. The implementation should:\n\n1. Identify and locate the three primary .mdc files used for Cursor Rules\n2. Extract content from these files and merge them into a single document\n3. Refactor the content to make it Windsurf-specific, replacing Cursor-specific terminology and adapting guidelines as needed\n4. Create a function that generates a .windsurfrules document from this content\n5. Integrate this function into the initialization pipeline\n6. Implement logic to check if a .windsurfrules document already exists:\n   - If it exists, append the new content to it\n   - If it doesn't exist, create a new document\n7. Ensure proper error handling for file operations\n8. Add appropriate logging to track the generation and modification of the .windsurfrules document\n\nThe implementation should be modular and maintainable, with clear separation of concerns between content extraction, refactoring, and file operations.",
      "testStrategy": "Testing should verify both the content generation and the integration with the initialization pipeline:\n\n1. Unit Tests:\n   - Test the content extraction function with mock .mdc files\n   - Test the content refactoring function to ensure Cursor-specific terms are properly replaced\n   - Test the file operation functions with mock filesystem\n\n2. Integration Tests:\n   - Test the creation of a new .windsurfrules document when none exists\n   - Test appending to an existing .windsurfrules document\n   - Test the complete initialization pipeline with the new functionality\n\n3. Manual Verification:\n   - Inspect the generated .windsurfrules document to ensure content is properly combined and refactored\n   - Verify that Cursor-specific terminology has been replaced with Windsurf-specific terminology\n   - Run the initialization process multiple times to verify idempotence (content isn't duplicated on multiple runs)\n\n4. Edge Cases:\n   - Test with missing or corrupted .mdc files\n   - Test with an existing but empty .windsurfrules document\n   - Test with an existing .windsurfrules document that already contains some of the content"
    },
    {
      "id": 34,
      "title": "Implement updateTask Command for Single Task Updates",
      "description": "Create a new command that allows updating a specific task by ID using AI-driven refinement while preserving completed subtasks and supporting all existing update command options.",
      "status": "done",
      "dependencies": [],
      "priority": "high",
      "details": "Implement a new command called 'updateTask' that focuses on updating a single task rather than all tasks from an ID onwards. The implementation should:\n\n1. Accept a single task ID as a required parameter\n2. Use the same AI-driven approach as the existing update command to refine the task\n3. Preserve the completion status of any subtasks that were previously marked as complete\n4. Support all options from the existing update command including:\n   - The research flag for Perplexity integration\n   - Any formatting or refinement options\n   - Task context options\n5. Update the CLI help documentation to include this new command\n6. Ensure the command follows the same pattern as other commands in the codebase\n7. Add appropriate error handling for cases where the specified task ID doesn't exist\n8. Implement the ability to update task title, description, and details separately if needed\n9. Ensure the command returns appropriate success/failure messages\n10. Optimize the implementation to only process the single task rather than scanning through all tasks\n\nThe command should reuse existing AI prompt templates where possible but modify them to focus on refining a single task rather than multiple tasks.",
      "testStrategy": "Testing should verify the following aspects:\n\n1. **Basic Functionality Test**: Verify that the command successfully updates a single task when given a valid task ID\n2. **Preservation Test**: Create a task with completed subtasks, update it, and verify the completion status remains intact\n3. **Research Flag Test**: Test the command with the research flag and verify it correctly integrates with Perplexity\n4. **Error Handling Tests**:\n   - Test with non-existent task ID and verify appropriate error message\n   - Test with invalid parameters and verify helpful error messages\n5. **Integration Test**: Run a complete workflow that creates a task, updates it with updateTask, and then verifies the changes are persisted\n6. **Comparison Test**: Compare the results of updating a single task with updateTask versus using the original update command on the same task to ensure consistent quality\n7. **Performance Test**: Measure execution time compared to the full update command to verify efficiency gains\n8. **CLI Help Test**: Verify the command appears correctly in help documentation with appropriate descriptions\n\nCreate unit tests for the core functionality and integration tests for the complete workflow. Document any edge cases discovered during testing.",
      "subtasks": [
        {
          "id": 1,
          "title": "Create updateTaskById function in task-manager.js",
          "description": "Implement a new function in task-manager.js that focuses on updating a single task by ID using AI-driven refinement while preserving completed subtasks.",
          "dependencies": [],
          "details": "Implementation steps:\n1. Create a new `updateTaskById` function in task-manager.js that accepts parameters: taskId, options object (containing research flag, formatting options, etc.)\n2. Implement logic to find a specific task by ID in the tasks array\n3. Add appropriate error handling for cases where the task ID doesn't exist (throw a custom error)\n4. Reuse existing AI prompt templates but modify them to focus on refining a single task\n5. Implement logic to preserve completion status of subtasks that were previously marked as complete\n6. Add support for updating task title, description, and details separately based on options\n7. Optimize the implementation to only process the single task rather than scanning through all tasks\n8. Return the updated task and appropriate success/failure messages\n\nTesting approach:\n- Unit test the function with various scenarios including:\n  - Valid task ID with different update options\n  - Non-existent task ID\n  - Task with completed subtasks to verify preservation\n  - Different combinations of update options",
          "status": "done",
          "parentTaskId": 34
        },
        {
          "id": 2,
          "title": "Implement updateTask command in commands.js",
          "description": "Create a new command called 'updateTask' in commands.js that leverages the updateTaskById function to update a specific task by ID.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Create a new command object for 'updateTask' in commands.js following the Command pattern\n2. Define command parameters including a required taskId parameter\n3. Support all options from the existing update command:\n   - Research flag for Perplexity integration\n   - Formatting and refinement options\n   - Task context options\n4. Implement the command handler function that calls the updateTaskById function from task-manager.js\n5. Add appropriate error handling to catch and display user-friendly error messages\n6. Ensure the command follows the same pattern as other commands in the codebase\n7. Implement proper validation of input parameters\n8. Format and return appropriate success/failure messages to the user\n\nTesting approach:\n- Unit test the command handler with various input combinations\n- Test error handling scenarios\n- Verify command options are correctly passed to the updateTaskById function",
          "status": "done",
          "parentTaskId": 34
        },
        {
          "id": 3,
          "title": "Add comprehensive error handling and validation",
          "description": "Implement robust error handling and validation for the updateTask command to ensure proper user feedback and system stability.",
          "dependencies": [
            1,
            2
          ],
          "details": "Implementation steps:\n1. Create custom error types for different failure scenarios (TaskNotFoundError, ValidationError, etc.)\n2. Implement input validation for the taskId parameter and all options\n3. Add proper error handling for AI service failures with appropriate fallback mechanisms\n4. Implement concurrency handling to prevent conflicts when multiple updates occur simultaneously\n5. Add comprehensive logging for debugging and auditing purposes\n6. Ensure all error messages are user-friendly and actionable\n7. Implement proper HTTP status codes for API responses if applicable\n8. Add validation to ensure the task exists before attempting updates\n\nTesting approach:\n- Test various error scenarios including invalid inputs, non-existent tasks, and API failures\n- Verify error messages are clear and helpful\n- Test concurrency scenarios with multiple simultaneous updates\n- Verify logging captures appropriate information for troubleshooting",
          "status": "done",
          "parentTaskId": 34
        },
        {
          "id": 4,
          "title": "Write comprehensive tests for updateTask command",
          "description": "Create a comprehensive test suite for the updateTask command to ensure it works correctly in all scenarios and maintains backward compatibility.",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Implementation steps:\n1. Create unit tests for the updateTaskById function in task-manager.js\n   - Test finding and updating tasks with various IDs\n   - Test preservation of completed subtasks\n   - Test different update options combinations\n   - Test error handling for non-existent tasks\n2. Create unit tests for the updateTask command in commands.js\n   - Test command parameter parsing\n   - Test option handling\n   - Test error scenarios and messages\n3. Create integration tests that verify the end-to-end flow\n   - Test the command with actual AI service integration\n   - Test with mock AI responses for predictable testing\n4. Implement test fixtures and mocks for consistent testing\n5. Add performance tests to ensure the command is efficient\n6. Test edge cases such as empty tasks, tasks with many subtasks, etc.\n\nTesting approach:\n- Use Jest or similar testing framework\n- Implement mocks for external dependencies like AI services\n- Create test fixtures for consistent test data\n- Use snapshot testing for command output verification",
          "status": "done",
          "parentTaskId": 34
        },
        {
          "id": 5,
          "title": "Update CLI documentation and help text",
          "description": "Update the CLI help documentation to include the new updateTask command and ensure users understand its purpose and options.",
          "dependencies": [
            2
          ],
          "details": "Implementation steps:\n1. Add comprehensive help text for the updateTask command including:\n   - Command description\n   - Required and optional parameters\n   - Examples of usage\n   - Description of all supported options\n2. Update the main CLI help documentation to include the new command\n3. Add the command to any relevant command groups or categories\n4. Create usage examples that demonstrate common scenarios\n5. Update README.md and other documentation files to include information about the new command\n6. Add inline code comments explaining the implementation details\n7. Update any API documentation if applicable\n8. Create or update user guides with the new functionality\n\nTesting approach:\n- Verify help text is displayed correctly when running `--help`\n- Review documentation for clarity and completeness\n- Have team members review the documentation for usability\n- Test examples to ensure they work as documented",
          "status": "done",
          "parentTaskId": 34
        }
      ]
    },
    {
      "id": 35,
      "title": "Integrate Grok3 API for Research Capabilities",
      "description": "Replace the current Perplexity API integration with Grok3 API for all research-related functionalities while maintaining existing feature parity.",
      "status": "pending",
      "dependencies": [],
      "priority": "medium",
      "details": "This task involves migrating from Perplexity to Grok3 API for research capabilities throughout the application. Implementation steps include:\n\n1. Create a new API client module for Grok3 in `src/api/grok3.ts` that handles authentication, request formatting, and response parsing\n2. Update the research service layer to use the new Grok3 client instead of Perplexity\n3. Modify the request payload structure to match Grok3's expected format (parameters like temperature, max_tokens, etc.)\n4. Update response handling to properly parse and extract Grok3's response format\n5. Implement proper error handling for Grok3-specific error codes and messages\n6. Update environment variables and configuration files to include Grok3 API keys and endpoints\n7. Ensure rate limiting and quota management are properly implemented according to Grok3's specifications\n8. Update any UI components that display research provider information to show Grok3 instead of Perplexity\n9. Maintain backward compatibility for any stored research results from Perplexity\n10. Document the new API integration in the developer documentation\n\nGrok3 API has different parameter requirements and response formats compared to Perplexity, so careful attention must be paid to these differences during implementation.",
      "testStrategy": "Testing should verify that the Grok3 API integration works correctly and maintains feature parity with the previous Perplexity implementation:\n\n1. Unit tests:\n   - Test the Grok3 API client with mocked responses\n   - Verify proper error handling for various error scenarios (rate limits, authentication failures, etc.)\n   - Test the transformation of application requests to Grok3-compatible format\n\n2. Integration tests:\n   - Perform actual API calls to Grok3 with test credentials\n   - Verify that research results are correctly parsed and returned\n   - Test with various types of research queries to ensure broad compatibility\n\n3. End-to-end tests:\n   - Test the complete research flow from UI input to displayed results\n   - Verify that all existing research features work with the new API\n\n4. Performance tests:\n   - Compare response times between Perplexity and Grok3\n   - Ensure the application handles any differences in response time appropriately\n\n5. Regression tests:\n   - Verify that existing features dependent on research capabilities continue to work\n   - Test that stored research results from Perplexity are still accessible and displayed correctly\n\nCreate a test environment with both APIs available to compare results and ensure quality before fully replacing Perplexity with Grok3."
    },
    {
      "id": 36,
      "title": "Add Ollama Support for AI Services as Claude Alternative",
      "description": "Implement Ollama integration as an alternative to Claude for all main AI services, allowing users to run local language models instead of relying on cloud-based Claude API.",
      "status": "pending",
      "dependencies": [],
      "priority": "medium",
      "details": "This task involves creating a comprehensive Ollama integration that can replace Claude across all main AI services in the application. Implementation should include:\n\n1. Create an OllamaService class that implements the same interface as the ClaudeService to ensure compatibility\n2. Add configuration options to specify Ollama endpoint URL (default: http://localhost:11434)\n3. Implement model selection functionality to allow users to choose which Ollama model to use (e.g., llama3, mistral, etc.)\n4. Handle prompt formatting specific to Ollama models, ensuring proper system/user message separation\n5. Implement proper error handling for cases where Ollama server is unavailable or returns errors\n6. Add fallback mechanism to Claude when Ollama fails or isn't configured\n7. Update the AI service factory to conditionally create either Claude or Ollama service based on configuration\n8. Ensure token counting and rate limiting are appropriately handled for Ollama models\n9. Add documentation for users explaining how to set up and use Ollama with the application\n10. Optimize prompt templates specifically for Ollama models if needed\n\nThe implementation should be toggled through a configuration option (useOllama: true/false) and should maintain all existing functionality currently provided by Claude.",
      "testStrategy": "Testing should verify that Ollama integration works correctly as a drop-in replacement for Claude:\n\n1. Unit tests:\n   - Test OllamaService class methods in isolation with mocked responses\n   - Verify proper error handling when Ollama server is unavailable\n   - Test fallback mechanism to Claude when configured\n\n2. Integration tests:\n   - Test with actual Ollama server running locally with at least two different models\n   - Verify all AI service functions work correctly with Ollama\n   - Compare outputs between Claude and Ollama for quality assessment\n\n3. Configuration tests:\n   - Verify toggling between Claude and Ollama works as expected\n   - Test with various model configurations\n\n4. Performance tests:\n   - Measure and compare response times between Claude and Ollama\n   - Test with different load scenarios\n\n5. Manual testing:\n   - Verify all main AI features work correctly with Ollama\n   - Test edge cases like very long inputs or specialized tasks\n\nCreate a test document comparing output quality between Claude and various Ollama models to help users understand the tradeoffs."
    },
    {
      "id": 37,
      "title": "Add Gemini Support for Main AI Services as Claude Alternative",
      "description": "Implement Google's Gemini API integration as an alternative to Claude for all main AI services, allowing users to switch between different LLM providers.",
      "status": "pending",
      "dependencies": [],
      "priority": "medium",
      "details": "This task involves integrating Google's Gemini API across all main AI services that currently use Claude:\n\n1. Create a new GeminiService class that implements the same interface as the existing ClaudeService\n2. Implement authentication and API key management for Gemini API\n3. Map our internal prompt formats to Gemini's expected input format\n4. Handle Gemini-specific parameters (temperature, top_p, etc.) and response parsing\n5. Update the AI service factory/provider to support selecting Gemini as an alternative\n6. Add configuration options in settings to allow users to select Gemini as their preferred provider\n7. Implement proper error handling for Gemini-specific API errors\n8. Ensure streaming responses are properly supported if Gemini offers this capability\n9. Update documentation to reflect the new Gemini option\n10. Consider implementing model selection if Gemini offers multiple models (e.g., Gemini Pro, Gemini Ultra)\n11. Ensure all existing AI capabilities (summarization, code generation, etc.) maintain feature parity when using Gemini\n\nThe implementation should follow the same pattern as the recent Ollama integration (Task #36) to maintain consistency in how alternative AI providers are supported.",
      "testStrategy": "Testing should verify Gemini integration works correctly across all AI services:\n\n1. Unit tests:\n   - Test GeminiService class methods with mocked API responses\n   - Verify proper error handling for common API errors\n   - Test configuration and model selection functionality\n\n2. Integration tests:\n   - Verify authentication and API connection with valid credentials\n   - Test each AI service with Gemini to ensure proper functionality\n   - Compare outputs between Claude and Gemini for the same inputs to verify quality\n\n3. End-to-end tests:\n   - Test the complete user flow of switching to Gemini and using various AI features\n   - Verify streaming responses work correctly if supported\n\n4. Performance tests:\n   - Measure and compare response times between Claude and Gemini\n   - Test with various input lengths to verify handling of context limits\n\n5. Manual testing:\n   - Verify the quality of Gemini responses across different use cases\n   - Test edge cases like very long inputs or specialized domain knowledge\n\nAll tests should pass with Gemini selected as the provider, and the user experience should be consistent regardless of which provider is selected."
    },
    {
      "id": 38,
      "title": "Implement Version Check System with Upgrade Notifications",
      "description": "Create a system that checks for newer package versions and displays upgrade notifications when users run any command, informing them to update to the latest version.",
      "status": "done",
      "dependencies": [],
      "priority": "high",
      "details": "Implement a version check mechanism that runs automatically with every command execution:\n\n1. Create a new module (e.g., `versionChecker.js`) that will:\n   - Fetch the latest version from npm registry using the npm registry API (https://registry.npmjs.org/task-master-ai/latest)\n   - Compare it with the current installed version (from package.json)\n   - Store the last check timestamp to avoid excessive API calls (check once per day)\n   - Cache the result to minimize network requests\n\n2. The notification should:\n   - Use colored text (e.g., yellow background with black text) to be noticeable\n   - Include the current version and latest version\n   - Show the exact upgrade command: 'npm i task-master-ai@latest'\n   - Be displayed at the beginning or end of command output, not interrupting the main content\n   - Include a small separator line to distinguish it from command output\n\n3. Implementation considerations:\n   - Handle network failures gracefully (don't block command execution if version check fails)\n   - Add a configuration option to disable update checks if needed\n   - Ensure the check is lightweight and doesn't significantly impact command performance\n   - Consider using a package like 'semver' for proper version comparison\n   - Implement a cooldown period (e.g., only check once per day) to avoid excessive API calls\n\n4. The version check should be integrated into the main command execution flow so it runs for all commands automatically.",
      "testStrategy": "1. Manual testing:\n   - Install an older version of the package\n   - Run various commands and verify the update notification appears\n   - Update to the latest version and confirm the notification no longer appears\n   - Test with network disconnected to ensure graceful handling of failures\n\n2. Unit tests:\n   - Mock the npm registry response to test different scenarios:\n     - When a newer version exists\n     - When using the latest version\n     - When the registry is unavailable\n   - Test the version comparison logic with various version strings\n   - Test the cooldown/caching mechanism works correctly\n\n3. Integration tests:\n   - Create a test that runs a command and verifies the notification appears in the expected format\n   - Test that the notification appears for all commands\n   - Verify the notification doesn't interfere with normal command output\n\n4. Edge cases to test:\n   - Pre-release versions (alpha/beta)\n   - Very old versions\n   - When package.json is missing or malformed\n   - When npm registry returns unexpected data"
    },
    {
      "id": 39,
      "title": "Update Project Licensing to Dual License Structure",
      "description": "Replace the current MIT license with a dual license structure that protects commercial rights for project owners while allowing non-commercial use under an open source license.",
      "status": "done",
      "dependencies": [],
      "priority": "high",
      "details": "This task requires implementing a comprehensive licensing update across the project:\n\n1. Remove all instances of the MIT license from the codebase, including any MIT license files, headers in source files, and references in documentation.\n\n2. Create a dual license structure with:\n   - Business Source License (BSL) 1.1 or similar for commercial use, explicitly stating that commercial rights are exclusively reserved for Ralph & Eyal\n   - Apache 2.0 for non-commercial use, allowing the community to use, modify, and distribute the code for non-commercial purposes\n\n3. Update the license field in package.json to reflect the dual license structure (e.g., \"BSL 1.1 / Apache 2.0\")\n\n4. Add a clear, concise explanation of the licensing terms in the README.md, including:\n   - A summary of what users can and cannot do with the code\n   - Who holds commercial rights\n   - How to obtain commercial use permission if needed\n   - Links to the full license texts\n\n5. Create a detailed LICENSE.md file that includes:\n   - Full text of both licenses\n   - Clear delineation between commercial and non-commercial use\n   - Specific definitions of what constitutes commercial use\n   - Any additional terms or clarifications specific to this project\n\n6. Create a CONTRIBUTING.md file that explicitly states:\n   - Contributors must agree that their contributions will be subject to the project's dual licensing\n   - Commercial rights for all contributions are assigned to Ralph & Eyal\n   - Guidelines for acceptable contributions\n\n7. Ensure all source code files include appropriate license headers that reference the dual license structure.",
      "testStrategy": "To verify correct implementation, perform the following checks:\n\n1. File verification:\n   - Confirm the MIT license file has been removed\n   - Verify LICENSE.md exists and contains both BSL and Apache 2.0 license texts\n   - Confirm README.md includes the license section with clear explanation\n   - Verify CONTRIBUTING.md exists with proper contributor guidelines\n   - Check package.json for updated license field\n\n2. Content verification:\n   - Review LICENSE.md to ensure it properly describes the dual license structure with clear terms\n   - Verify README.md license section is concise yet complete\n   - Check that commercial rights are explicitly reserved for Ralph & Eyal in all relevant documents\n   - Ensure CONTRIBUTING.md clearly explains the licensing implications for contributors\n\n3. Legal review:\n   - Have a team member not involved in the implementation review all license documents\n   - Verify that the chosen BSL terms properly protect commercial interests\n   - Confirm the Apache 2.0 implementation is correct and compatible with the BSL portions\n\n4. Source code check:\n   - Sample at least 10 source files to ensure they have updated license headers\n   - Verify no MIT license references remain in any source files\n\n5. Documentation check:\n   - Ensure any documentation that mentioned licensing has been updated to reflect the new structure",
      "subtasks": [
        {
          "id": 1,
          "title": "Remove MIT License and Create Dual License Files",
          "description": "Remove all MIT license references from the codebase and create the new license files for the dual license structure.",
          "dependencies": [],
          "details": "Implementation steps:\n1. Scan the entire codebase to identify all instances of MIT license references (license files, headers in source files, documentation mentions).\n2. Remove the MIT license file and all direct references to it.\n3. Create a LICENSE.md file containing:\n   - Full text of Business Source License (BSL) 1.1 with explicit commercial rights reservation for Ralph & Eyal\n   - Full text of Apache 2.0 license for non-commercial use\n   - Clear definitions of what constitutes commercial vs. non-commercial use\n   - Specific terms for obtaining commercial use permission\n4. Create a CONTRIBUTING.md file that explicitly states the contribution terms:\n   - Contributors must agree to the dual licensing structure\n   - Commercial rights for all contributions are assigned to Ralph & Eyal\n   - Guidelines for acceptable contributions\n\nTesting approach:\n- Verify all MIT license references have been removed using a grep or similar search tool\n- Have legal review of the LICENSE.md and CONTRIBUTING.md files to ensure they properly protect commercial rights\n- Validate that the license files are properly formatted and readable",
          "status": "done",
          "parentTaskId": 39
        },
        {
          "id": 2,
          "title": "Update Source Code License Headers and Package Metadata",
          "description": "Add appropriate dual license headers to all source code files and update package metadata to reflect the new licensing structure.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Create a template for the new license header that references the dual license structure (BSL 1.1 / Apache 2.0).\n2. Systematically update all source code files to include the new license header, replacing any existing MIT headers.\n3. Update the license field in package.json to \"BSL 1.1 / Apache 2.0\".\n4. Update any other metadata files (composer.json, setup.py, etc.) that contain license information.\n5. Verify that any build scripts or tools that reference licensing information are updated.\n\nTesting approach:\n- Write a script to verify that all source files contain the new license header\n- Validate package.json and other metadata files have the correct license field\n- Ensure any build processes that depend on license information still function correctly\n- Run a sample build to confirm license information is properly included in any generated artifacts",
          "status": "done",
          "parentTaskId": 39
        },
        {
          "id": 3,
          "title": "Update Documentation and Create License Explanation",
          "description": "Update project documentation to clearly explain the dual license structure and create comprehensive licensing guidance.",
          "dependencies": [
            1,
            2
          ],
          "details": "Implementation steps:\n1. Update the README.md with a clear, concise explanation of the licensing terms:\n   - Summary of what users can and cannot do with the code\n   - Who holds commercial rights (Ralph & Eyal)\n   - How to obtain commercial use permission\n   - Links to the full license texts\n2. Create a dedicated LICENSING.md or similar document with detailed explanations of:\n   - The rationale behind the dual licensing approach\n   - Detailed examples of what constitutes commercial vs. non-commercial use\n   - FAQs addressing common licensing questions\n3. Update any other documentation references to licensing throughout the project.\n4. Create visual aids (if appropriate) to help users understand the licensing structure.\n5. Ensure all documentation links to licensing information are updated.\n\nTesting approach:\n- Have non-technical stakeholders review the documentation for clarity and understanding\n- Verify all links to license files work correctly\n- Ensure the explanation is comprehensive but concise enough for users to understand quickly\n- Check that the documentation correctly addresses the most common use cases and questions",
          "status": "done",
          "parentTaskId": 39
        }
      ]
    },
    {
      "id": 40,
      "title": "Implement 'plan' Command for Task Implementation Planning",
      "description": "Create a new 'plan' command that appends a structured implementation plan to tasks or subtasks, generating step-by-step instructions for execution based on the task content.",
      "status": "pending",
      "dependencies": [],
      "priority": "medium",
      "details": "Implement a new 'plan' command that will append a structured implementation plan to existing tasks or subtasks. The implementation should:\n\n1. Accept an '--id' parameter that can reference either a task or subtask ID\n2. Determine whether the ID refers to a task or subtask and retrieve the appropriate content from tasks.json and/or individual task files\n3. Generate a step-by-step implementation plan using AI (Claude by default)\n4. Support a '--research' flag to use Perplexity instead of Claude when needed\n5. Format the generated plan within XML tags like `<implementation_plan as of timestamp>...</implementation_plan>`\n6. Append this plan to the implementation details section of the task/subtask\n7. Display a confirmation card indicating the implementation plan was successfully created\n\nThe implementation plan should be detailed and actionable, containing specific steps such as searching for files, creating new files, modifying existing files, etc. The goal is to frontload planning work into the task/subtask so execution can begin immediately.\n\nReference the existing 'update-subtask' command implementation as a starting point, as it uses a similar approach for appending content to tasks. Ensure proper error handling for cases where the specified ID doesn't exist or when API calls fail.",
      "testStrategy": "Testing should verify:\n\n1. Command correctly identifies and retrieves content for both task and subtask IDs\n2. Implementation plans are properly generated and formatted with XML tags and timestamps\n3. Plans are correctly appended to the implementation details section without overwriting existing content\n4. The '--research' flag successfully switches the backend from Claude to Perplexity\n5. Appropriate error messages are displayed for invalid IDs or API failures\n6. Confirmation card is displayed after successful plan creation\n\nTest cases should include:\n- Running 'plan --id 123' on an existing task\n- Running 'plan --id 123.1' on an existing subtask\n- Running 'plan --id 123 --research' to test the Perplexity integration\n- Running 'plan --id 999' with a non-existent ID to verify error handling\n- Running the command on tasks with existing implementation plans to ensure proper appending\n\nManually review the quality of generated plans to ensure they provide actionable, step-by-step guidance that accurately reflects the task requirements."
    },
    {
      "id": 41,
      "title": "Implement Visual Task Dependency Graph in Terminal",
      "description": "Create a feature that renders task dependencies as a visual graph using ASCII/Unicode characters in the terminal, with color-coded nodes representing tasks and connecting lines showing dependency relationships.",
      "status": "pending",
      "dependencies": [],
      "priority": "medium",
      "details": "This implementation should include:\n\n1. Create a new command `graph` or `visualize` that displays the dependency graph.\n\n2. Design an ASCII/Unicode-based graph rendering system that:\n   - Represents each task as a node with its ID and abbreviated title\n   - Shows dependencies as directional lines between nodes (, , , etc.)\n   - Uses color coding for different task statuses (e.g., green for completed, yellow for in-progress, red for blocked)\n   - Handles complex dependency chains with proper spacing and alignment\n\n3. Implement layout algorithms to:\n   - Minimize crossing lines for better readability\n   - Properly space nodes to avoid overlapping\n   - Support both vertical and horizontal graph orientations (as a configurable option)\n\n4. Add detection and highlighting of circular dependencies with a distinct color/pattern\n\n5. Include a legend explaining the color coding and symbols used\n\n6. Ensure the graph is responsive to terminal width, with options to:\n   - Automatically scale to fit the current terminal size\n   - Allow zooming in/out of specific sections for large graphs\n   - Support pagination or scrolling for very large dependency networks\n\n7. Add options to filter the graph by:\n   - Specific task IDs or ranges\n   - Task status\n   - Dependency depth (e.g., show only direct dependencies or N levels deep)\n\n8. Ensure accessibility by using distinct patterns in addition to colors for users with color vision deficiencies\n\n9. Optimize performance for projects with many tasks and complex dependency relationships",
      "testStrategy": "1. Unit Tests:\n   - Test the graph generation algorithm with various dependency structures\n   - Verify correct node placement and connection rendering\n   - Test circular dependency detection\n   - Verify color coding matches task statuses\n\n2. Integration Tests:\n   - Test the command with projects of varying sizes (small, medium, large)\n   - Verify correct handling of different terminal sizes\n   - Test all filtering options\n\n3. Visual Verification:\n   - Create test cases with predefined dependency structures and verify the visual output matches expected patterns\n   - Test with terminals of different sizes, including very narrow terminals\n   - Verify readability of complex graphs\n\n4. Edge Cases:\n   - Test with no dependencies (single nodes only)\n   - Test with circular dependencies\n   - Test with very deep dependency chains\n   - Test with wide dependency networks (many parallel tasks)\n   - Test with the maximum supported number of tasks\n\n5. Usability Testing:\n   - Have team members use the feature and provide feedback on readability and usefulness\n   - Test in different terminal emulators to ensure compatibility\n   - Verify the feature works in terminals with limited color support\n\n6. Performance Testing:\n   - Measure rendering time for large projects\n   - Ensure reasonable performance with 100+ interconnected tasks"
    },
    {
      "id": 42,
      "title": "Implement MCP-to-MCP Communication Protocol",
      "description": "Design and implement a communication protocol that allows Taskmaster to interact with external MCP (Model Context Protocol) tools and servers, enabling programmatic operations across these tools without requiring custom integration code. The system should dynamically connect to MCP servers chosen by the user for task storage and management (e.g., GitHub-MCP or Postgres-MCP). This eliminates the need for separate APIs or SDKs for each service. The goal is to create a standardized, agnostic system that facilitates seamless task execution and interaction with external systems. Additionally, the system should support two operational modes: **solo/local mode**, where tasks are managed locally using a `tasks.json` file, and **multiplayer/remote mode**, where tasks are managed via external MCP integrations. The core modules of Taskmaster should dynamically adapt their operations based on the selected mode, with multiplayer/remote mode leveraging MCP servers for all task management operations.",
      "status": "pending",
      "dependencies": [],
      "priority": "medium",
      "details": "This task involves creating a standardized way for Taskmaster to communicate with external MCP implementations and tools. The implementation should:\n\n1. Define a standard protocol for communication with MCP servers, including authentication, request/response formats, and error handling.\n2. Leverage the existing `fastmcp` server logic to enable interaction with external MCP tools programmatically, focusing on creating a modular and reusable system.\n3. Implement an adapter pattern that allows Taskmaster to connect to any MCP-compliant tool or server.\n4. Build a client module capable of discovering, connecting to, and exchanging data with external MCP tools, ensuring compatibility with various implementations.\n5. Provide a reference implementation for interacting with a specific MCP tool (e.g., GitHub-MCP or Postgres-MCP) to demonstrate the protocol's functionality.\n6. Ensure the protocol supports versioning to maintain compatibility as MCP tools evolve.\n7. Implement rate limiting and backoff strategies to prevent overwhelming external MCP tools.\n8. Create a configuration system that allows users to specify connection details for external MCP tools and servers.\n9. Add support for two operational modes:\n   - **Solo/Local Mode**: Tasks are managed locally using a `tasks.json` file.\n   - **Multiplayer/Remote Mode**: Tasks are managed via external MCP integrations (e.g., GitHub-MCP or Postgres-MCP). The system should dynamically switch between these modes based on user configuration.\n10. Update core modules to perform task operations on the appropriate system (local or remote) based on the selected mode, with remote mode relying entirely on MCP servers for task management.\n11. Document the protocol thoroughly to enable other developers to implement it in their MCP tools.\n\nThe implementation should prioritize asynchronous communication where appropriate and handle network failures gracefully. Security considerations, including encryption and robust authentication mechanisms, should be integral to the design.",
      "testStrategy": "Testing should verify both the protocol design and implementation:\n\n1. Unit tests for the adapter pattern, ensuring it correctly translates between Taskmaster's internal models and the MCP protocol.\n2. Integration tests with a mock MCP tool or server to validate the full request/response cycle.\n3. Specific tests for the reference implementation (e.g., GitHub-MCP or Postgres-MCP), including authentication flows.\n4. Error handling tests that simulate network failures, timeouts, and malformed responses.\n5. Performance tests to ensure the communication does not introduce significant latency.\n6. Security tests to verify that authentication and encryption mechanisms are functioning correctly.\n7. End-to-end tests demonstrating Taskmaster's ability to programmatically interact with external MCP tools and execute tasks.\n8. Compatibility tests with different versions of the protocol to ensure backward compatibility.\n9. Tests for mode switching:\n   - Validate that Taskmaster correctly operates in solo/local mode using the `tasks.json` file.\n   - Validate that Taskmaster correctly operates in multiplayer/remote mode with external MCP integrations (e.g., GitHub-MCP or Postgres-MCP).\n   - Ensure seamless switching between modes without data loss or corruption.\n10. A test harness should be created to simulate an MCP tool or server for testing purposes without relying on external dependencies. Test cases should be documented thoroughly to serve as examples for other implementations.",
      "subtasks": [
        {
          "id": "42-1",
          "title": "Define MCP-to-MCP communication protocol",
          "status": "pending"
        },
        {
          "id": "42-2",
          "title": "Implement adapter pattern for MCP integration",
          "status": "pending"
        },
        {
          "id": "42-3",
          "title": "Develop client module for MCP tool discovery and interaction",
          "status": "pending"
        },
        {
          "id": "42-4",
          "title": "Provide reference implementation for GitHub-MCP integration",
          "status": "pending"
        },
        {
          "id": "42-5",
          "title": "Add support for solo/local and multiplayer/remote modes",
          "status": "pending"
        },
        {
          "id": "42-6",
          "title": "Update core modules to support dynamic mode-based operations",
          "status": "pending"
        },
        {
          "id": "42-7",
          "title": "Document protocol and mode-switching functionality",
          "status": "pending"
        },
        {
          "id": "42-8",
          "title": "Update terminology to reflect MCP server-based communication",
          "status": "pending"
        }
      ]
    }
  ]
}